<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AetherSwap PRO</title>
  <style>
    :root {
      --primary: #6e45e2;
      --primary-hover: #5934ba;
      --bg: #0f0f0f;
      --surface: #1a1a2f;
      --text: #eee;
      --text-muted: #aaa;
      --danger: #ff4d4d;
      --success: #4dffb5;
      --radius-lg: 16px;
      --radius-md: 12px;
      --radius-sm: 8px;
      --shadow: 0 8px 24px rgba(0,0,0,0.7);
      --transition: 0.2s ease;
    }

    /* Modern 2025 DEX styles */
    .swap-container {
      max-width: 480px;
      background: var(--surface);
      border-radius: var(--radius-lg);
      padding: 24px;
      box-shadow: var(--shadow);
    }

    .token-input {
      background: rgba(255,255,255,0.05);
      border-radius: var(--radius-md);
      padding: 16px;
      margin-bottom: 12px;
      transition: all var(--transition);
    }

    .token-input.active {
      border: 1px solid var(--primary);
      box-shadow: 0 0 0 1px var(--primary);
    }

    .token-selector {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      user-select: none;
    }

    .token-selector:hover {
      opacity: 0.9;
    }

    .token-logo {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #fff;
      object-fit: contain;
    }

    .token-symbol {
      font-weight: 700;
      font-size: 1.2rem;
    }

    .token-balance {
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .amount-input {
      width: 100%;
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 1.5rem;
      text-align: right;
      margin: 8px 0;
    }

    .amount-input:focus {
      outline: none;
    }

    .usd-value {
      text-align: right;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .swap-arrow {
      background: var(--surface);
      border: 2px solid var(--bg);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: -12px auto;
      cursor: pointer;
      z-index: 2;
      position: relative;
      transition: all var(--transition);
    }

    .swap-arrow:hover {
      transform: rotate(180deg);
      background: var(--primary);
    }

    .swap-button {
      width: 100%;
      background: var(--primary);
      color: white;
      border: none;
      padding: 16px;
      border-radius: var(--radius-md);
      font-weight: 700;
      font-size: 1.1rem;
      cursor: pointer;
      margin-top: 16px;
      transition: all var(--transition);
    }

    .swap-button:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
    }

    .swap-button:disabled {
      background: #3a3a5a;
      cursor: not-allowed;
      transform: none;
    }

    .swap-details {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .detail-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.9rem;
    }

    .price-impact {
      color: var(--success);
    }

    .price-impact.high {
      color: var(--danger);
    }

    /* Token modal */
    .token-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .token-modal.active {
      opacity: 1;
      pointer-events: all;
    }

    .token-modal-content {
      background: var(--surface);
      border-radius: var(--radius-lg);
      width: 90%;
      max-width: 420px;
      max-height: 80vh;
      overflow: hidden;
      transform: translateY(20px);
      transition: transform 0.2s ease;
    }

    .token-modal.active .token-modal-content {
      transform: translateY(0);
    }

    .token-search {
      padding: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .token-search input {
      width: 100%;
      padding: 12px 16px;
      background: rgba(255,255,255,0.05);
      border: none;
      border-radius: var(--radius-md);
      color: var(--text);
      font-size: 1rem;
    }

    .token-list {
      max-height: 60vh;
      overflow-y: auto;
    }

    .token-item {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      transition: all var(--transition);
    }

    .token-item:hover {
      background: rgba(110, 69, 226, 0.2);
    }

    .token-item-info {
      flex: 1;
    }

    .token-item-symbol {
      font-weight: 700;
    }

    .token-item-name {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .token-item-balance {
      text-align: right;
    }

    /* Network status */
    .network-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 16px;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }

    /* Responsive */
    @media (max-width: 480px) {
      .swap-container {
        padding: 16px;
      }
      
      .token-input {
        padding: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="swap-container">
    <div class="network-status">
      <div class="status-indicator"></div>
      <span>Solana Mainnet</span>
      <span>•</span>
      <span>Fast: 0.0005 SOL</span>
    </div>

    <div class="token-input active">
      <div class="token-selector" id="fromTokenSelector">
        <img src="" alt="" class="token-logo" id="fromTokenLogo">
        <div>
          <div class="token-symbol" id="fromTokenSymbol">Select</div>
          <div class="token-balance">Balance: <span id="fromTokenBalance">0.0</span></div>
        </div>
      </div>
      <input type="text" class="amount-input" id="fromAmount" placeholder="0.0">
      <div class="usd-value">≈ $<span id="fromAmountUSD">0.00</span></div>
    </div>

    <button class="swap-arrow" id="switchTokens">↓↑</button>

    <div class="token-input">
      <div class="token-selector" id="toTokenSelector">
        <img src="" alt="" class="token-logo" id="toTokenLogo">
        <div>
          <div class="token-symbol" id="toTokenSymbol">Select</div>
          <div class="token-balance">Balance: <span id="toTokenBalance">0.0</span></div>
        </div>
      </div>
      <input type="text" class="amount-input" id="toAmount" placeholder="0.0" readonly>
      <div class="usd-value">≈ $<span id="toAmountUSD">0.00</span></div>
    </div>

    <div class="swap-details">
      <div class="detail-row">
        <span>Exchange Rate</span>
        <span id="exchangeRate">1 ETH = 0.0 USDC</span>
      </div>
      <div class="detail-row">
        <span>Price Impact</span>
        <span class="price-impact" id="priceImpact"><0.01%</span>
      </div>
      <div class="detail-row">
        <span>Network Fee</span>
        <span id="networkFee">~$0.00</span>
      </div>
    </div>

    <button class="swap-button" id="swapButton" disabled>Connect Wallet</button>
  </div>

  <!-- Token Selection Modal -->
  <div class="token-modal" id="tokenModal">
    <div class="token-modal-content">
      <div class="token-search">
        <input type="text" id="tokenSearch" placeholder="Search token name or address...">
      </div>
      <div class="token-list" id="tokenList">
        <!-- Tokens will be loaded here -->
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const config = {
      defaultSlippage: 0.5, // 0.5%
      jupiterAPI: 'https://lite-api.jup.ag/tokens/v2/list'
    };

    // State
    let state = {
      fromToken: null,
      toToken: null,
      tokens: [],
      wallet: null,
      balances: {},
      quote: null,
      selectingFor: null
    };

    // DOM Elements
    const elements = {
      fromTokenSelector: document.getElementById('fromTokenSelector'),
      toTokenSelector: document.getElementById('toTokenSelector'),
      fromTokenLogo: document.getElementById('fromTokenLogo'),
      toTokenLogo: document.getElementById('toTokenLogo'),
      fromTokenSymbol: document.getElementById('fromTokenSymbol'),
      toTokenSymbol: document.getElementById('toTokenSymbol'),
      fromTokenBalance: document.getElementById('fromTokenBalance'),
      toTokenBalance: document.getElementById('toTokenBalance'),
      fromAmount: document.getElementById('fromAmount'),
      toAmount: document.getElementById('toAmount'),
      fromAmountUSD: document.getElementById('fromAmountUSD'),
      toAmountUSD: document.getElementById('toAmountUSD'),
      switchTokens: document.getElementById('switchTokens'),
      swapButton: document.getElementById('swapButton'),
      tokenModal: document.getElementById('tokenModal'),
      tokenSearch: document.getElementById('tokenSearch'),
      tokenList: document.getElementById('tokenList'),
      exchangeRate: document.getElementById('exchangeRate'),
      priceImpact: document.getElementById('priceImpact'),
      networkFee: document.getElementById('networkFee')
    };

    // Initialize
    async function init() {
      await loadTokens();
      setupEventListeners();
      
      // Try auto-connecting wallet if previously connected
      if (window.solana && window.solana.isConnected) {
        connectWallet();
      }
    }

    // Load token list from Jupiter API
    async function loadTokens() {
      try {
        const response = await fetch(`${config.jupiterAPI}/tokens`);
        const data = await response.json();
        
        // Sort tokens by volume/liquidity (simplified)
        state.tokens = Object.values(data.data)
          .filter(token => token.chainId === 101) // Mainnet only
          .sort((a, b) => {
            // Prioritize tokens with logo and known symbols
            if (a.logoURI && !b.logoURI) return -1;
            if (!a.logoURI && b.logoURI) return 1;
            return a.symbol.localeCompare(b.symbol);
          });
      } catch (error) {
        console.error('Failed to load tokens:', error);
      }
    }

    // Setup all event listeners
    function setupEventListeners() {
      // Token selection
      elements.fromTokenSelector.addEventListener('click', () => openTokenModal('from'));
      elements.toTokenSelector.addEventListener('click', () => openTokenModal('to'));
      elements.switchTokens.addEventListener('click', switchTokens);

      // Amount input
      elements.fromAmount.addEventListener('input', debounce(updateQuote, 300));

      // Swap button
      elements.swapButton.addEventListener('click', executeSwap);

      // Token modal
      elements.tokenSearch.addEventListener('input', searchTokens);
      document.addEventListener('click', (e) => {
        if (e.target === elements.tokenModal) {
          closeTokenModal();
        }
      });

      // Wallet connection
      if (window.solana) {
        window.solana.on('connect', () => {
          state.wallet = window.solana;
          updateWalletState();
          loadBalances();
        });
        
        window.solana.on('disconnect', () => {
          state.wallet = null;
          updateWalletState();
        });
      }
    }

    // Open token selection modal
    function openTokenModal(forToken) {
      state.selectingFor = forToken;
      elements.tokenSearch.value = '';
      renderTokenList(state.tokens);
      elements.tokenModal.classList.add('active');
      elements.tokenSearch.focus();
    }

    // Close token modal
    function closeTokenModal() {
      elements.tokenModal.classList.remove('active');
    }

    // Render token list in modal
    function renderTokenList(tokens) {
      elements.tokenList.innerHTML = '';

      if (tokens.length === 0) {
        elements.tokenList.innerHTML = '<div class="token-item">No tokens found</div>';
        return;
      }

      tokens.forEach(token => {
        const tokenItem = document.createElement('div');
        tokenItem.className = 'token-item';
        tokenItem.innerHTML = `
          <img src="${token.logoURI || ''}" alt="${token.symbol}" class="token-logo" onerror="this.style.display='none'">
          <div class="token-item-info">
            <div class="token-item-symbol">${token.symbol}</div>
            <div class="token-item-name">${token.name}</div>
          </div>
          <div class="token-item-balance">${state.balances[token.address] || '0.0'}</div>
        `;
        
        tokenItem.addEventListener('click', () => selectToken(token));
        elements.tokenList.appendChild(tokenItem);
      });
    }

    // Search tokens by name/symbol/address
    function searchTokens() {
      const query = elements.tokenSearch.value.toLowerCase();
      if (!query) {
        renderTokenList(state.tokens);
        return;
      }

      const filtered = state.tokens.filter(token => 
        token.symbol.toLowerCase().includes(query) ||
        token.name.toLowerCase().includes(query) ||
        token.address.toLowerCase().includes(query)
      );

      renderTokenList(filtered);
    }

    // Select token from modal
    function selectToken(token) {
      if (state.selectingFor === 'from') {
        state.fromToken = token;
        elements.fromTokenSymbol.textContent = token.symbol;
        elements.fromTokenLogo.src = token.logoURI || '';
        elements.fromTokenLogo.style.display = token.logoURI ? 'block' : 'none';
        elements.fromTokenBalance.textContent = state.balances[token.address] || '0.0';
      } else {
        state.toToken = token;
        elements.toTokenSymbol.textContent = token.symbol;
        elements.toTokenLogo.src = token.logoURI || '';
        elements.toTokenLogo.style.display = token.logoURI ? 'block' : 'none';
        elements.toTokenBalance.textContent = state.balances[token.address] || '0.0';
      }

      closeTokenModal();
      updateQuote();
      updateUI();
    }

    // Switch from/to tokens
    function switchTokens() {
      if (!state.fromToken || !state.toToken) return;

      const temp = state.fromToken;
      state.fromToken = state.toToken;
      state.toToken = temp;

      // Update UI
      elements.fromTokenSymbol.textContent = state.fromToken.symbol;
      elements.fromTokenLogo.src = state.fromToken.logoURI || '';
      elements.fromTokenLogo.style.display = state.fromToken.logoURI ? 'block' : 'none';
      elements.fromTokenBalance.textContent = state.balances[state.fromToken.address] || '0.0';

      elements.toTokenSymbol.textContent = state.toToken.symbol;
      elements.toTokenLogo.src = state.toToken.logoURI || '';
      elements.toTokenLogo.style.display = state.toToken.logoURI ? 'block' : 'none';
      elements.toTokenBalance.textContent = state.balances[state.toToken.address] || '0.0';

      // Keep amount if switching with amount entered
      if (elements.fromAmount.value) {
        const tempAmount = elements.fromAmount.value;
        elements.fromAmount.value = elements.toAmount.value;
        elements.toAmount.value = tempAmount;
      }

      updateQuote();
    }

    // Connect wallet
    async function connectWallet() {
      if (!window.solana) {
        alert('Phantom wallet not detected!');
        return;
      }

      try {
        const response = await window.solana.connect();
        state.wallet = window.solana;
        updateWalletState();
        loadBalances();
      } catch (error) {
        console.error('Wallet connection failed:', error);
      }
    }

    // Load token balances for connected wallet
    async function loadBalances() {
      if (!state.wallet) return;

      try {
        const connection = new window.solanaWeb3.Connection(
          window.solanaWeb3.clusterApiUrl('mainnet-beta')
        );

        // Load SOL balance
        const solBalance = await connection.getBalance(state.wallet.publicKey);
        state.balances['So11111111111111111111111111111111111111112'] = 
          (solBalance / window.solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);

        // Load SPL token balances
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
          state.wallet.publicKey,
          { programId: new window.solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') }
        );

        tokenAccounts.value.forEach(account => {
          const info = account.account.data.parsed.info;
          state.balances[info.mint] = info.tokenAmount.uiAmountString;
        });

        // Update displayed balances
        if (state.fromToken) {
          elements.fromTokenBalance.textContent = 
            state.balances[state.fromToken.address] || '0.0';
        }
        if (state.toToken) {
          elements.toTokenBalance.textContent = 
            state.balances[state.toToken.address] || '0.0';
        }

      } catch (error) {
        console.error('Failed to load balances:', error);
      }
    }

    // Update wallet connection state
    function updateWalletState() {
      if (state.wallet) {
        elements.swapButton.textContent = 'Swap Now';
        elements.swapButton.disabled = !state.quote;
      } else {
        elements.swapButton.textContent = 'Connect Wallet';
        elements.swapButton.disabled = false;
      }
    }

    // Get swap quote from Jupiter API
    async function updateQuote() {
      if (!state.fromToken || !state.toToken || !elements.fromAmount.value) {
        elements.toAmount.value = '';
        elements.swapButton.disabled = true;
        return;
      }

      const amount = parseFloat(elements.fromAmount.value);
      if (isNaN(amount) || amount <= 0) {
        elements.toAmount.value = '';
        elements.swapButton.disabled = true;
        return;
      }

      try {
        // Convert to smallest units
        const amountInSmallestUnits = Math.floor(
          amount * Math.pow(10, state.fromToken.decimals)
        );

        const params = new URLSearchParams();
        params.append('inputMint', state.fromToken.address);
        params.append('outputMint', state.toToken.address);
        params.append('amount', amountInSmallestUnits.toString());
        params.append('slippageBps', (config.defaultSlippage * 100).toString());

        const response = await fetch(`${config.jupiterAPI}/quote?${params.toString()}`);
        const data = await response.json();

        if (data.data && data.data.length > 0) {
          state.quote = data.data[0];
          const outAmount = parseFloat(state.quote.outAmount) / Math.pow(10, state.toToken.decimals);
          
          elements.toAmount.value = outAmount.toFixed(6);
          elements.exchangeRate.textContent = `1 ${state.fromToken.symbol} = ${(outAmount / amount).toFixed(6)} ${state.toToken.symbol}`;
          
          // Update price impact
          const priceImpact = parseFloat(state.quote.priceImpactPct) * 100;
          elements.priceImpact.textContent = `${priceImpact.toFixed(2)}%`;
          elements.priceImpact.className = priceImpact > 1 ? 'price-impact high' : 'price-impact';
          
          // Update network fee (simplified)
          elements.networkFee.textContent = '~$0.50'; // Would calculate from quote in real implementation
          
          // Enable swap button if wallet connected
          elements.swapButton.disabled = !state.wallet;
        } else {
          elements.toAmount.value = '';
          elements.swapButton.disabled = true;
        }
      } catch (error) {
        console.error('Failed to get quote:', error);
        elements.toAmount.value = '';
        elements.swapButton.disabled = true;
      }
    }

    // Execute swap
    async function executeSwap() {
      if (!state.wallet) {
        connectWallet();
        return;
      }

      if (!state.quote) {
        alert('Invalid swap parameters');
        return;
      }

      try {
        elements.swapButton.disabled = true;
        elements.swapButton.textContent = 'Processing...';

        const swapResponse = await fetch(`${config.jupiterAPI}/swap`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            route: state.quote,
            userPublicKey: state.wallet.publicKey.toString(),
            wrapUnwrapSOL: true
          })
        });

        const swapData = await swapResponse.json();

        if (!swapData.swapTransaction) {
          throw new Error('No swap transaction returned');
        }

        const transaction = window.solanaWeb3.Transaction.from(
          Buffer.from(swapData.swapTransaction, 'base64')
        );

        const signed = await state.wallet.signTransaction(transaction);
        const connection = new window.solanaWeb3.Connection(
          window.solanaWeb3.clusterApiUrl('mainnet-beta')
        );
        const txid = await connection.sendRawTransaction(signed.serialize());

        alert(`Swap submitted! TX ID: ${txid}`);
        
        // Reset form
        elements.fromAmount.value = '';
        elements.toAmount.value = '';
        state.quote = null;
        
        // Reload balances
        await loadBalances();
        
      } catch (error) {
        console.error('Swap failed:', error);
        alert(`Swap failed: ${error.message}`);
      } finally {
        elements.swapButton.textContent = 'Swap Now';
        elements.swapButton.disabled = false;
      }
    }

    // Debounce function for input
    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this, args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    // Update UI based on state
    function updateUI() {
      // Enable/disable swap button
      elements.swapButton.disabled = !state.wallet || !state.quote;
      
      // Update USD values (simplified - would use price API in production)
      if (elements.fromAmount.value && state.fromToken) {
        elements.fromAmountUSD.textContent = (parseFloat(elements.fromAmount.value) * 1.5).toFixed(2); // Mock conversion
      } else {
        elements.fromAmountUSD.textContent = '0.00';
      }
      
      if (elements.toAmount.value && state.toToken) {
        elements.toAmountUSD.textContent = (parseFloat(elements.toAmount.value) * 1.0).toFixed(2); // Mock conversion
      } else {
        elements.toAmountUSD.textContent = '0.00';
      }
    }

    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', init);
  </script>

  <!-- Solana Web3.js -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.70.1/lib/index.iife.min.js"></script>
</body>
</html>