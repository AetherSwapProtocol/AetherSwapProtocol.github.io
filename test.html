<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AetherSwap - Solana DEX Swap</title>
<!-- Tailwind CDN -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Include Solana Web3.js -->
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
<style>
  /* Liquid Glass effect for container */
  body {
    background: linear-gradient(135deg, #1e1e2f 0%, #4b3f72 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  .liquid-glass {
    background: rgba(255 255 255 / 0.12);
    backdrop-filter: blur(12px);
    border-radius: 18px;
    border: 1px solid rgba(255 255 255 / 0.15);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.35);
  }
  /* Custom scrollbar for token list */
  .token-list::-webkit-scrollbar {
    width: 8px;
  }
  .token-list::-webkit-scrollbar-thumb {
    background: #777;
    border-radius: 4px;
  }
</style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 text-white">

<div class="w-full max-w-3xl liquid-glass p-6 space-y-6">

  <header class="flex justify-between items-center mb-4">
    <h1 class="text-3xl font-extrabold text-indigo-400">AetherSwap</h1>
    <button id="connectWalletBtn" class="px-4 py-2 rounded-md bg-indigo-600 hover:bg-indigo-700 transition">
      Connect Wallet
    </button>
  </header>

  <!-- Swap container -->
  <section class="space-y-4">
    <!-- Token A input -->
    <div class="flex items-center space-x-3">
      <button id="selectTokenA" class="flex items-center space-x-2 bg-indigo-700 hover:bg-indigo-800 rounded-md px-3 py-1">
        <img id="tokenALogo" src="https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png" alt="Token A" class="w-6 h-6 rounded-full" />
        <span id="tokenASymbol" class="text-lg font-semibold">SOL</span>
        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" >
          <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      <input type="number" id="inputAmountA" placeholder="0.0" min="0" step="any" class="flex-1 bg-indigo-900/50 rounded-md px-3 py-2 text-white font-mono text-xl" />
      <span id="balanceA" class="text-sm text-indigo-300">Balance: 0</span>
    </div>

    <!-- Swap direction button -->
    <div class="flex justify-center">
      <button id="swapDirectionBtn" class="rounded-full bg-indigo-600 p-2 hover:bg-indigo-700 transition" title="Invert tokens">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M17 8l4 4m0 0l-4 4m4-4H3" />
        </svg>
      </button>
    </div>

    <!-- Token B output -->
    <div class="flex items-center space-x-3">
      <button id="selectTokenB" class="flex items-center space-x-2 bg-indigo-700 hover:bg-indigo-800 rounded-md px-3 py-1">
        <img id="tokenBLogo" src="https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERdFFL4q8d2h5nUWTiG9hqYCP5PeCM4VzB/logo.png" alt="Token B" class="w-6 h-6 rounded-full" />
        <span id="tokenBSymbol" class="text-lg font-semibold">USDC</span>
        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" >
          <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      <input type="text" id="inputAmountB" readonly placeholder="0.0" class="flex-1 bg-indigo-900/50 rounded-md px-3 py-2 text-white font-mono text-xl" />
      <span id="balanceB" class="text-sm text-indigo-300">Balance: 0</span>
    </div>

    <!-- Slippage tolerance selector -->
    <div class="flex items-center space-x-2 text-indigo-300">
      <label for="slippageSelect">Slippage tolerance:</label>
      <select id="slippageSelect" class="bg-indigo-900/50 rounded-md px-2 py-1 text-white cursor-pointer">
        <option value="0.1">0.1%</option>
        <option value="0.5" selected>0.5%</option>
        <option value="1">1%</option>
        <option value="2">2%</option>
        <option value="3">3%</option>
      </select>
    </div>

    <!-- Swap button -->
    <button id="swapBtn" disabled class="w-full py-3 rounded-md bg-indigo-500 hover:bg-indigo-600 transition text-xl font-bold">
      Swap
    </button>
  </section>

  <!-- Token selection modal -->
  <div id="tokenModal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50">
    <div class="bg-indigo-900 rounded-lg max-w-xl w-full max-h-[80vh] overflow-hidden flex flex-col">
      <div class="flex justify-between items-center p-4 border-b border-indigo-700">
        <h2 class="text-xl font-bold text-white">Select a token</h2>
        <button id="closeTokenModal" class="text-white hover:text-indigo-400 text-2xl font-bold">&times;</button>
      </div>
      <input type="text" id="tokenSearchInput" placeholder="Search by name, symbol or mint address" class="m-4 p-2 rounded-md text-black" />
      <div id="tokenList" class="overflow-y-auto token-list flex-1 px-4 pb-4"></div>
    </div>
  </div>

  <!-- Status & error messages -->
  <div id="statusMsg" class="mt-4 text-center text-indigo-300"></div>

  <!-- Moonpay on-ramp -->
  <section class="mt-10">
    <h3 class="text-xl font-semibold mb-3 text-indigo-400">Buy Crypto with Moonpay</h3>
    <iframe
      src="https://buy.moonpay.com/?apiKey=YOUR_MOONPAY_API_KEY&currencyCode=sol"
      class="w-full h-96 rounded-lg border border-indigo-700"
      allow="payment"
      loading="lazy"
      title="Moonpay Buy Crypto"
    ></iframe>
  </section>

</div>

<script>
  (() => {
    // Global State
    let walletPublicKey = null;
    let connection;
    const solanaWeb3 = window.solanaWeb3;
    const SOL_MINT = "So11111111111111111111111111111111111111112";
    const USDC_MINT = "Es9vMFrzaCERdFFL4q8d2h5nUWTiG9hqYCP5PeCM4VzB";
    // Selected tokens state
    let tokenA = {
      mint: SOL_MINT,
      symbol: "SOL",
      decimals: 9,
      logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png",
    };
    let tokenB = {
      mint: USDC_MINT,
      symbol: "USDC",
      decimals: 6,
      logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERdFFL4q8d2h5nUWTiG9hqYCP5PeCM4VzB/logo.png",
    };

    // Tokens list (loaded from multi-source)
    let tokensList = [];

    // UI Elements
    const connectWalletBtn = document.getElementById("connectWalletBtn");
    const swapBtn = document.getElementById("swapBtn");
    const swapDirectionBtn = document.getElementById("swapDirectionBtn");
    const selectTokenAButton = document.getElementById("selectTokenA");
    const selectTokenBButton = document.getElementById("selectTokenB");
    const tokenModal = document.getElementById("tokenModal");
    const closeTokenModalBtn = document.getElementById("closeTokenModal");
    const tokenSearchInput = document.getElementById("tokenSearchInput");
    const tokenListDiv = document.getElementById("tokenList");
    const inputAmountA = document.getElementById("inputAmountA");
    const inputAmountB = document.getElementById("inputAmountB");
    const slippageSelect = document.getElementById("slippageSelect");
    const statusMsg = document.getElementById("statusMsg");
    const tokenALogo = document.getElementById("tokenALogo");
    const tokenBLogo = document.getElementById("tokenBLogo");
    const tokenASymbol = document.getElementById("tokenASymbol");
    const tokenBSymbol = document.getElementById("tokenBSymbol");
    const balanceA = document.getElementById("balanceA");
    const balanceB = document.getElementById("balanceB");

    // Modal state
    let selectingTokenFor = null; // "A" or "B"

    // Initialize Solana connection
    connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("mainnet-beta"));

    // Util: format lamports to SOL with decimals
    function formatAmount(amount, decimals) {
      return (amount / Math.pow(10, decimals)).toFixed(6);
    }
    function parseAmount(input, decimals) {
      return Math.floor(parseFloat(input) * Math.pow(10, decimals));
    }

    // Connect to Phantom wallet
    async function connectWallet() {
      if (!window.solana || !window.solana.isPhantom) {
        alert("Phantom Wallet is not installed. Please install it.");
        return;
      }
      try {
        const resp = await window.solana.connect();
        walletPublicKey = resp.publicKey.toString();
        connectWalletBtn.textContent = "Connected: " + walletPublicKey.slice(0, 6) + "..." + walletPublicKey.slice(-4);
        connectWalletBtn.disabled = true;
        statusMsg.textContent = "";
        // After connect, fetch balances of selected tokens
        await fetchAndDisplayBalances();
      } catch (err) {
        console.error("Wallet connection error:", err);
        statusMsg.textContent = "Wallet connection failed.";
      }
    }

    // Disconnect wallet (optional)
    function disconnectWallet() {
      walletPublicKey = null;
      connectWalletBtn.textContent = "Connect Wallet";
      connectWalletBtn.disabled = false;
      balanceA.textContent = "Balance: 0";
      balanceB.textContent = "Balance: 0";
    }

    // Fetch tokens list from multiple sources (Dexscreener + Jupiter)
    async function fetchTokensList() {
      try {
        // Dexscreener Solana tokens
        const dsResp = await fetch("https://api.dexscreener.com/latest/dex/tokens/solana");
        const dsData = await dsResp.json();
        const dsTokens = dsData.tokens || [];

        // Jupiter tokens list
        const jupResp = await fetch("https://quote-api.jup.ag/v1/tokens");
        const jupData = await jupResp.json();
        const jupTokens = jupData.data || [];

        // Merge and dedupe by mint address
        const mapTokens = new Map();

        for (const t of dsTokens) {
          if (!t.address) continue;
          mapTokens.set(t.address, {
            mint: t.address,
            symbol: t.symbol || t.name || t.address.slice(0, 6),
            name: t.name || "",
            decimals: t.decimals || 0,
            logoURI: t.icon || t.logo || null,
          });
        }
        for (const t of jupTokens) {
          if (!t.address) continue;
          if (!mapTokens.has(t.address)) {
            mapTokens.set(t.address, {
              mint: t.address,
              symbol: t.symbol || t.name || t.address.slice(0, 6),
              name: t.name || "",
              decimals: t.decimals || 0,
              logoURI: t.logoURI || null,
            });
          }
        }
        // Ensure SOL and USDC are present (add manually if missing)
        if (!mapTokens.has(SOL_MINT)) {
          mapTokens.set(SOL_MINT, {
            mint: SOL_MINT,
            symbol: "SOL",
            name: "Solana",
            decimals: 9,
            logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png",
          });
        }
        if (!mapTokens.has(USDC_MINT)) {
          mapTokens.set(USDC_MINT, {
            mint: USDC_MINT,
            symbol: "USDC",
            name: "USD Coin",
            decimals: 6,
            logoURI: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERdFFL4q8d2h5nUWTiG9hqYCP5PeCM4VzB/logo.png",
          });
        }

        tokensList = Array.from(mapTokens.values());
        tokensList.sort((a, b) => a.symbol.localeCompare(b.symbol));
      } catch (error) {
        console.error("Failed to fetch tokens list:", error);
        statusMsg.textContent = "Failed to fetch tokens list.";
      }
    }

    // Render token list in modal with filtering
    function renderTokenList(filter = "") {
      tokenListDiv.innerHTML = "";
      const filterLC = filter.toLowerCase();
      const filteredTokens = tokensList.filter(
        (t) =>
          t.symbol.toLowerCase().includes(filterLC) ||
          t.name.toLowerCase().includes(filterLC) ||
          t.mint.toLowerCase().includes(filterLC)
      );

      if (filteredTokens.length === 0) {
        tokenListDiv.innerHTML = `<p class="text-indigo-400 text-center py-4">No tokens found</p>`;
        return;
      }

      for (const token of filteredTokens) {
        const div = document.createElement("div");
        div.className = "flex items-center space-x-3 p-2 rounded-md hover:bg-indigo-700 cursor-pointer";

        const img = document.createElement("img");
        img.src = token.logoURI || "https://via.placeholder.com/32?text=?";
        img.alt = token.symbol;
        img.className = "w-8 h-8 rounded-full flex-shrink-0";

        const textDiv = document.createElement("div");
        textDiv.className = "flex flex-col";

        const symSpan = document.createElement("span");
        symSpan.className = "font-semibold text-white";
        symSpan.textContent = token.symbol;

        const nameSpan = document.createElement("span");
        nameSpan.className = "text-indigo-300 text-sm";
        nameSpan.textContent = token.name;

        textDiv.appendChild(symSpan);
        textDiv.appendChild(nameSpan);

        div.appendChild(img);
        div.appendChild(textDiv);

        div.onclick = () => {
          selectToken(token);
          closeTokenModal();
        };

        tokenListDiv.appendChild(div);
      }
    }

    // Show token modal
    function openTokenModal(forToken) {
      selectingTokenFor = forToken; // "A" or "B"
      tokenSearchInput.value = "";
      renderTokenList();
      tokenModal.classList.remove("hidden");
      tokenSearchInput.focus();
    }
    // Close token modal
    function closeTokenModal() {
      tokenModal.classList.add("hidden");
      selectingTokenFor = null;
    }

    // Select token from modal
    async function selectToken(token) {
      if (selectingTokenFor === "A") {
        if (token.mint === tokenB.mint) {
          alert("Token A and Token B must be different");
          return;
        }
        tokenA = token;
        tokenALogo.src = token.logoURI || "https://via.placeholder.com/32?text=?";
        tokenASymbol.textContent = token.symbol;
      } else if (selectingTokenFor === "B") {
        if (token.mint === tokenA.mint) {
          alert("Token A and Token B must be different");
          return;
        }
        tokenB = token;
        tokenBLogo.src = token.logoURI || "https://via.placeholder.com/32?text=?";
        tokenBSymbol.textContent = token.symbol;
      }
      await fetchAndDisplayBalances();
      // Clear inputs & outputs after token change
      inputAmountA.value = "";
      inputAmountB.value = "";
      swapBtn.disabled = true;
    }

    // Fetch user token balance for a given token mint
    async function fetchBalance(mintAddress) {
      if (!walletPublicKey) return 0;
      try {
        if (mintAddress === SOL_MINT) {
          // Fetch SOL balance in lamports
          const pubkey = new solanaWeb3.PublicKey(walletPublicKey);
          const balanceLamports = await connection.getBalance(pubkey);
          return balanceLamports / 1e9;
        } else {
          // Fetch SPL token balance
          const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
            new solanaWeb3.PublicKey(walletPublicKey),
            { mint: new solanaWeb3.PublicKey(mintAddress) }
          );
          let amount = 0;
          if (tokenAccounts.value.length > 0) {
            const parsed = tokenAccounts.value[0].account.data.parsed.info.tokenAmount;
            amount = parsed.uiAmount || 0;
          }
          return amount;
        }
      } catch (error) {
        console.error("Failed to fetch balance:", error);
        return 0;
      }
    }

    // Fetch and display balances for tokenA and tokenB
    async function fetchAndDisplayBalances() {
      if (!walletPublicKey) return;
      balanceA.textContent = "Balance: ...";
      balanceB.textContent = "Balance: ...";
      const balA = await fetchBalance(tokenA.mint);
      const balB = await fetchBalance(tokenB.mint);
      balanceA.textContent = `Balance: ${balA.toFixed(4)}`;
      balanceB.textContent = `Balance: ${balB.toFixed(4)}`;
    }

    // Swap direction invert tokens
    async function invertTokens() {
      const temp = tokenA;
      tokenA = tokenB;
      tokenB = temp;

      // Update UI logos and symbols
      tokenALogo.src = tokenA.logoURI || "https://via.placeholder.com/32?text=?";
      tokenASymbol.textContent = tokenA.symbol;
      tokenBLogo.src = tokenB.logoURI || "https://via.placeholder.com/32?text=?";
      tokenBSymbol.textContent = tokenB.symbol;

      // Clear input/output
      inputAmountA.value = "";
      inputAmountB.value = "";
      swapBtn.disabled = true;

      // Refresh balances
      await fetchAndDisplayBalances();
    }

    // Query Jupiter API for route and output amount estimation
    async function getJupiterQuote(amountInRaw) {
      if (amountInRaw <= 0) return null;
      try {
        const slippage = parseFloat(slippageSelect.value);
        const url = `https://quote-api.jup.ag/v1/quote?inputMint=${tokenA.mint}&outputMint=${tokenB.mint}&amount=${amountInRaw}&slippageBps=${Math.floor(slippage * 100)}&onlyDirectRoutes=false&useMultipleTransitiveRoutes=true`;
        const resp = await fetch(url);
        const data = await resp.json();
        if (!data || !data.data || data.data.length === 0) return null;
        // Return best quote route info
        return data.data[0];
      } catch (error) {
        console.error("Failed to fetch Jupiter quote:", error);
        return null;
      }
    }

    // Estimate tokenB amount based on tokenA input
    async function estimateOutputAmount() {
      const inputStr = inputAmountA.value.trim();
      if (!inputStr || isNaN(inputStr)) {
        inputAmountB.value = "";
        swapBtn.disabled = true;
        return;
      }
      const amountInRaw = parseAmount(inputStr, tokenA.decimals);
      if (amountInRaw <= 0) {
        inputAmountB.value = "";
        swapBtn.disabled = true;
        return;
      }

      statusMsg.textContent = "Fetching quote...";
      const quote = await getJupiterQuote(amountInRaw);
      if (!quote) {
        inputAmountB.value = "";
        swapBtn.disabled = true;
        statusMsg.textContent = "No valid swap route found.";
        return;
      }

      // amountOut: raw output amount
      const amountOutRaw = quote.outAmount;
      const amountOutFormatted = (amountOutRaw / Math.pow(10, tokenB.decimals)).toFixed(6);
      inputAmountB.value = amountOutFormatted;
      swapBtn.disabled = false;
      statusMsg.textContent = "";
    }

    // Perform the swap via Jupiter API + Phantom Wallet signing
    async function executeSwap() {
      if (!walletPublicKey) {
        alert("Please connect your wallet first.");
        return;
      }
      const amountInStr = inputAmountA.value.trim();
      if (!amountInStr || isNaN(amountInStr) || parseFloat(amountInStr) <= 0) {
        alert("Enter a valid amount to swap.");
        return;
      }
      const amountInRaw = parseAmount(amountInStr, tokenA.decimals);

      statusMsg.textContent = "Fetching best swap route...";
      swapBtn.disabled = true;

      // Get quote with slippage
      const slippage = parseFloat(slippageSelect.value);
      const quoteUrl = `https://quote-api.jup.ag/v1/quote?inputMint=${tokenA.mint}&outputMint=${tokenB.mint}&amount=${amountInRaw}&slippageBps=${Math.floor(slippage * 100)}&onlyDirectRoutes=false&useMultipleTransitiveRoutes=true`;
      const resp = await fetch(quoteUrl);
      const data = await resp.json();
      if (!data || !data.data || data.data.length === 0) {
        statusMsg.textContent = "No swap route found.";
        swapBtn.disabled = false;
        return;
      }
      const route = data.data[0];

      // Prepare transaction for Phantom signing
      try {
        const transactions = route.swapTransaction; // base64 encoded
        const txBuffer = Buffer.from(transactions, "base64");
        const connectionSol = connection;

        // Deserialize transaction (using solanaWeb3)
        const tx = solanaWeb3.Transaction.from(txBuffer);

        // Set recent blockhash & fee payer (optional: re-fetch for safety)
        const recentBlockhash = (await connectionSol.getRecentBlockhash()).blockhash;
        tx.recentBlockhash = recentBlockhash;
        tx.feePayer = new solanaWeb3.PublicKey(walletPublicKey);

        // Sign transaction with Phantom wallet
        statusMsg.textContent = "Requesting signature from Phantom wallet...";
        const signedTx = await window.solana.signTransaction(tx);

        // Send signed transaction to Solana
        const txid = await connectionSol.sendRawTransaction(signedTx.serialize());
        statusMsg.textContent = `Swap submitted. Txid: ${txid}`;

        // Confirm transaction
        await connectionSol.confirmTransaction(txid, 'confirmed');
        statusMsg.textContent = `Swap confirmed! Txid: ${txid}`;
        swapBtn.disabled = false;
        // Refresh balances
        await fetchAndDisplayBalances();

        // Clear inputs
        inputAmountA.value = "";
        inputAmountB.value = "";
      } catch (error) {
        console.error("Swap error:", error);
        statusMsg.textContent = "Swap failed or canceled.";
        swapBtn.disabled = false;
      }
    }

    // Event Listeners
    connectWalletBtn.onclick = connectWallet;
    selectTokenAButton.onclick = () => openTokenModal("A");
    selectTokenBButton.onclick = () => openTokenModal("B");
    closeTokenModalBtn.onclick = closeTokenModal;
    tokenSearchInput.oninput = (e) => renderTokenList(e.target.value);

    swapDirectionBtn.onclick = invertTokens;

    inputAmountA.oninput = estimateOutputAmount;
    slippageSelect.onchange = estimateOutputAmount;

    swapBtn.onclick = executeSwap;

    // Initialize app
    async function init() {
      statusMsg.textContent = "Loading tokens list...";
      await fetchTokensList();
      statusMsg.textContent = "Ready. Connect wallet to start swapping.";
      // Initial balances empty
      balanceA.textContent = "Balance: -";
      balanceB.textContent = "Balance: -";
    }

    // Run init on load
    window.onload = init;

  })();
</script>

</body>
</html>