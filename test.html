<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AetherSwap — Pro Solana DEX</title>
<style>
  /* ====== BASE STYLES & RESET ====== */
  *, *::before, *::after {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0;
    font-family: 'Inter', sans-serif;
    background: linear-gradient(135deg, #0b0d14 0%, #121623 100%);
    color: #e6eaf0;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }
  /* ====== CONTAINER ====== */
  #app {
    width: 100%;
    max-width: 440px;
    background: rgba(255 255 255 / 0.05);
    border-radius: 24px;
    padding: 32px 28px;
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255 255 255 / 0.1);
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  /* ====== HEADER ====== */
  header {
    font-weight: 700;
    font-size: 1.8rem;
    text-align: center;
    color: #8da9ff;
    letter-spacing: 1px;
    user-select: none;
  }

  /* ====== WALLET CONNECT UI ====== */
  #wallet-controls {
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  button {
    background: linear-gradient(135deg, #4f5bd5 0%, #962fbf 100%);
    border: none;
    border-radius: 12px;
    color: white;
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    padding: 12px 24px;
    user-select: none;
    transition: background 0.3s ease;
  }
  button:disabled {
    cursor: default;
    opacity: 0.6;
  }
  button:hover:not(:disabled) {
    background: linear-gradient(135deg, #5a69ff 0%, #ab3cff 100%);
  }
  /* Wallet address display */
  #wallet-info {
    background: rgba(255 255 255 / 0.1);
    border-radius: 12px;
    padding: 10px 16px;
    font-size: 0.9rem;
    font-family: monospace;
    user-select: text;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #wallet-address {
    overflow-wrap: anywhere;
    flex: 1;
    color: #aab8ff;
  }
  #wallet-balance {
    margin-left: 12px;
    font-weight: 700;
    color: #c0d2ff;
  }
  #disconnect-btn {
    margin-left: 16px;
    background: transparent;
    border: 2px solid #ff4d4d;
    color: #ff4d4d;
    padding: 6px 14px;
    font-weight: 700;
    border-radius: 12px;
    transition: all 0.3s ease;
  }
  #disconnect-btn:hover {
    background: #ff4d4d;
    color: white;
  }

  /* ====== SWAP BOX ====== */
  #swap-box {
    background: rgba(255 255 255 / 0.08);
    border-radius: 20px;
    padding: 24px 20px;
    display: flex;
    flex-direction: column;
    gap: 18px;
  }

  .token-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .token-btn {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 14px;
    background: rgba(255 255 255 / 0.12);
    border-radius: 14px;
    border: 1px solid transparent;
    cursor: pointer;
    transition: border-color 0.3s ease;
    user-select: none;
  }
  .token-btn:hover {
    border-color: #798bff;
  }
  .token-logo {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #ddd;
    flex-shrink: 0;
  }
  .token-symbol {
    font-weight: 700;
    font-size: 1.1rem;
    color: #d1dbff;
  }
  .balance {
    font-size: 0.85rem;
    color: #8a95b2;
    margin-left: auto;
  }
  input.amount-input {
    width: 110px;
    font-size: 1.25rem;
    font-weight: 600;
    background: transparent;
    border: none;
    color: #c9d1ff;
    text-align: right;
    outline-offset: 2px;
  }
  input.amount-input::-webkit-inner-spin-button,
  input.amount-input::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  input.amount-input:disabled {
    color: #555a7b;
  }

  /* Slippage and info row */
  #slippage-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 6px;
  }
  label.slippage-label {
    font-size: 0.9rem;
    color: #8890b0;
  }
  input.slippage-input {
    width: 70px;
    padding: 6px 10px;
    border-radius: 12px;
    border: 1px solid #5961a1;
    background: rgba(255 255 255 / 0.05);
    color: #bcc2ff;
    font-weight: 600;
    text-align: right;
    user-select: text;
  }
  input.slippage-input::-webkit-inner-spin-button,
  input.slippage-input::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Rate display */
  #rate-display {
    font-size: 0.9rem;
    color: #9aa4db;
    user-select: none;
    margin-top: 8px;
  }

  /* Swap button */
  #swap-btn {
    margin-top: 20px;
    background: linear-gradient(135deg, #3f6fe6, #8849d6);
    border: none;
    padding: 16px;
    font-size: 1.2rem;
    font-weight: 700;
    color: white;
    border-radius: 18px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #swap-btn:disabled {
    background: rgba(63, 111, 230, 0.5);
    cursor: default;
  }
  #swap-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, #557cff, #a155f0);
  }

  /* Modal Background */
  #modal-bg {
    position: fixed;
    inset: 0;
    background: rgba(11, 13, 20, 0.8);
    backdrop-filter: blur(16px);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
  }
  /* Modal box */
  #token-modal {
    background: rgba(255 255 255 / 0.05);
    border-radius: 20px;
    width: 100%;
    max-width: 360px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    padding: 16px;
  }
  #modal-header {
    font-weight: 700;
    font-size: 1.2rem;
    margin-bottom: 12px;
    color: #8ea2ff;
  }
  #modal-search {
    padding: 8px 14px;
    border-radius: 14px;
    border: none;
    background: rgba(255 255 255 / 0.1);
    color: white;
    font-size: 1rem;
    margin-bottom: 12px;
    outline-offset: 2px;
  }
  #token-list {
    overflow-y: auto;
    flex-grow: 1;
    scrollbar-width: thin;
    scrollbar-color: #8890b0 transparent;
  }
  #token-list::-webkit-scrollbar {
    width: 6px;
  }
  #token-list::-webkit-scrollbar-thumb {
    background-color: #8890b0;
    border-radius: 4px;
  }
  .token-list-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    border-radius: 14px;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }
  .token-list-item:hover {
    background: rgba(255 255 255 / 0.15);
  }
  .token-list-logo {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #ddd;
    flex-shrink: 0;
  }
  .token-list-symbol {
    font-weight: 700;
    color: #d1dbff;
    user-select: none;
  }
  .token-list-balance {
    margin-left: auto;
    font-size: 0.85rem;
    color: #8a95b2;
    user-select: none;
  }

  /* Notifications container */
  #notifications {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    max-width: 380px;
    width: 90vw;
    z-index: 3000;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .toast {
    background: rgba(33, 33, 33, 0.9);
    color: white;
    padding: 14px 22px;
    border-radius: 16px;
    box-shadow: 0 0 14px rgba(255 255 255 / 0.15);
    font-weight: 600;
    user-select: none;
    animation: slidein 0.4s ease forwards;
  }
  .toast-error {
    background: #bb3e3e;
  }
  .toast-success {
    background: #3ebb6e;
  }
  @keyframes slidein {
    from {
      transform: translateX(-50%) translateY(40px);
      opacity: 0;
    }
    to {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  }

  /* Loader spinner */
  #loader {
    display: none;
    margin: 0 auto;
    border: 4px solid rgba(255 255 255 / 0.15);
    border-top: 4px solid #8ea2ff;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    100% { transform: rotate(360deg); }
  }

  /* Responsive tweaks */
  @media (max-width: 480px) {
    #app {
      padding: 24px 20px;
    }
    input.amount-input {
      width: 90px;
      font-size: 1.1rem;
    }
    button {
      padding: 10px 18px;
      font-size: 0.95rem;
    }
  }
</style>
</head>
<body>
<div id="app" role="main" aria-label="AetherSwap decentralized exchange">

<header>AetherSwap</header>

<section id="wallet-section" aria-label="Wallet connection and information">
  <div id="wallet-controls" aria-live="polite" aria-atomic="true">
    <button id="connect-btn" type="button" aria-describedby="connect-desc">Connect Phantom Wallet</button>
    <span id="connect-desc" class="sr-only">Connect your Phantom wallet to use AetherSwap</span>
  </div>
  <div id="wallet-info" style="display:none;" aria-live="polite" aria-atomic="true">
    <div id="wallet-address" aria-label="Connected wallet address"></div>
    <div id="wallet-balance" aria-label="SOL balance"></div>
    <button id="disconnect-btn" type="button" aria-label="Disconnect wallet">Disconnect</button>
  </div>
</section>

<section id="swap-box" aria-label="Token swap interface" hidden>
  <div class="token-row">
    <button id="token-from-btn" class="token-btn" aria-haspopup="dialog" aria-expanded="false" aria-controls="token-modal" aria-label="Select token to swap from">
      <img src="" alt="" class="token-logo" id="token-from-logo" />
      <span class="token-symbol" id="token-from-symbol">Select Token A</span>
      <span class="balance" id="balance-from"></span>
    </button>
    <input id="amount-from" class="amount-input" type="number" min="0" step="any" aria-label="Amount to swap from" />
  </div>
  <div class="token-row" style="margin-top:12px;">
    <button id="token-to-btn" class="token-btn" aria-haspopup="dialog" aria-expanded="false" aria-controls="token-modal" aria-label="Select token to swap to">
      <img src="" alt="" class="token-logo" id="token-to-logo" />
      <span class="token-symbol" id="token-to-symbol">Select Token B</span>
      <span class="balance" id="balance-to"></span>
    </button>
    <input id="amount-to" class="amount-input" type="text" disabled aria-label="Estimated amount to receive" />
  </div>

  <div id="slippage-container">
    <label for="slippage-input" class="slippage-label">Slippage tolerance (%)</label>
    <input id="slippage-input" class="slippage-input" type="number" min="0" max="10" step="0.1" value="0.5" aria-describedby="slippage-desc" />
  </div>
  <div id="slippage-desc" class="sr-only">Set maximum slippage tolerance for swap, default 0.5 percent</div>

  <div id="rate-display" aria-live="polite" aria-atomic="true">Rate: -</div>
  <button id="swap-btn" type="button" disabled>Swap</button>
  <div id="loader" role="status" aria-live="polite" aria-label="Loading indicator"></div>
</section>

<!-- Token selection modal -->
<div id="modal-bg" role="dialog" aria-modal="true" aria-labelledby="modal-header">
  <div id="token-modal">
    <div id="modal-header">Select a Token</div>
    <input type="search" id="modal-search" placeholder="Search token by name, symbol or address" aria-label="Search tokens" />
    <div id="token-list" tabindex="0" role="list" aria-live="polite" aria-atomic="true"></div>
  </div>
</div>

<!-- Notifications container -->
<div id="notifications" aria-live="assertive" aria-atomic="true" aria-relevant="additions"></div>

<script type="module">
// ----------- IMPORTS AND SETUP ------------
// We'll use solana wallet adapter phantom and solana/web3.js from CDN
import { Connection, PublicKey, Transaction } from "https://cdn.jsdelivr.net/npm/@solana/web3.js@1.73.0/+esm";
import {
  PhantomWalletAdapter
} from "https://cdn.jsdelivr.net/npm/@solana/wallet-adapter-phantom@0.18.0/+esm";

// Jupiter Ultra SDK imports - unofficial (simulate calls)
// For production, use the official @jup-ag/core and @jup-ag/token-lists packages

// ----------- CONSTANTS & GLOBALS ------------
const SOL_MINT = "So11111111111111111111111111111111111111112";

const connection = new Connection("https://api.mainnet-beta.solana.com", "confirmed");

const wallet = new PhantomWalletAdapter();
let walletPublicKey = null;

let tokens = []; // Array of token metadata {address, symbol, name, decimals, logoURI, balance}
let selectedFrom = null;
let selectedTo = null;
let amountFrom = 0;
let amountTo = 0;
let slippage = 0.5;
let swapQuote = null; // Will hold quote details

// HTML elements cache
const connectBtn = document.getElementById("connect-btn");
const disconnectBtn = document.getElementById("disconnect-btn");
const walletControls = document.getElementById("wallet-controls");
const walletInfo = document.getElementById("wallet-info");
const walletAddress = document.getElementById("wallet-address");
const walletBalance = document.getElementById("wallet-balance");
const swapBox = document.getElementById("swap-box");
const tokenFromBtn = document.getElementById("token-from-btn");
const tokenToBtn = document.getElementById("token-to-btn");
const tokenFromLogo = document.getElementById("token-from-logo");
const tokenToLogo = document.getElementById("token-to-logo");
const tokenFromSymbol = document.getElementById("token-from-symbol");
const tokenToSymbol = document.getElementById("token-to-symbol");
const balanceFromEl = document.getElementById("balance-from");
const balanceToEl = document.getElementById("balance-to");
const amountFromInput = document.getElementById("amount-from");
const amountToInput = document.getElementById("amount-to");
const slippageInput = document.getElementById("slippage-input");
const rateDisplay = document.getElementById("rate-display");
const swapBtn = document.getElementById("swap-btn");
const loader = document.getElementById("loader");
const modalBg = document.getElementById("modal-bg");
const tokenModal = document.getElementById("token-modal");
const modalSearch = document.getElementById("modal-search");
const tokenList = document.getElementById("token-list");
const notifications = document.getElementById("notifications");

// For which token selector is open ('from' or 'to')
let currentModalTarget = null;

// ---------- UTILITIES ----------
function showLoader(show) {
  loader.style.display = show ? "block" : "none";
}

function abbreviateAddress(addr) {
  if (!addr) return "";
  return addr.slice(0, 4) + "..." + addr.slice(-4);
}

function showNotification(msg, type = "success", timeout = 4000) {
  const toast = document.createElement("div");
  toast.className = "toast " + (type === "error" ? "toast-error" : "toast-success");
  toast.textContent = msg;
  notifications.appendChild(toast);
  setTimeout(() => {
    toast.style.opacity = "0";
    setTimeout(() => notifications.removeChild(toast), 500);
  }, timeout);
}

function formatAmount(amount, decimals = 6) {
  if (typeof amount !== "number") return "-";
  return Number(amount).toFixed(decimals);
}

function sleep(ms) {
  return new Promise((res) => setTimeout(res, ms));
}

// --------- TOKEN LIST FETCH --------
// Using official Solana token list from jup.ag repo (top ~100 tokens)
async function fetchTokenList() {
  try {
    const res = await fetch("https://cache.jup.ag/tokens");
    if (!res.ok) throw new Error("Token list fetch failed");
    const data = await res.json();
    // Filter top 100 by rank (some tokens don't have rank)
    let filtered = data.filter(t => t.chainId === 101); // Solana mainnet
    filtered.sort((a, b) => (a.rank || 9999) - (b.rank || 9999));
    tokens = filtered.slice(0, 100).map(token => ({
      address: token.address,
      symbol: token.symbol,
      name: token.name,
      decimals: token.decimals,
      logoURI: token.logoURI,
      balance: 0
    }));
  } catch(e) {
    showNotification("Failed to load token list", "error");
  }
}

// ---------- WALLET & BALANCE ----------

async function updateBalances() {
  if (!walletPublicKey) return;
  // Get SOL balance
  try {
    let solBalanceRaw = await connection.getBalance(walletPublicKey);
    let solBalance = solBalanceRaw / 1e9;
    walletBalance.textContent = `${solBalance.toFixed(4)} SOL`;
    // Update balance for tokens
    // For demo: simulate 0 balance for tokens (could integrate getTokenAccountsByOwner)
    for(let token of tokens) {
      token.balance = 0; // reset
    }
    // Get token accounts owned by wallet
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(walletPublicKey, { programId: new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") });
    for(const { account } of tokenAccounts.value) {
      const info = account.data.parsed.info;
      const mint = info.mint;
      const amountRaw = info.tokenAmount.uiAmount;
      let t = tokens.find(tk => tk.address === mint);
      if(t) t.balance = amountRaw;
    }
  } catch (err) {
    showNotification("Failed to fetch balances", "error");
  }
}

async function connectWallet() {
  if (!wallet.ready) {
    showNotification("Phantom wallet not found", "error");
    return;
  }
  try {
    await wallet.connect();
    walletPublicKey = wallet.publicKey;
    walletAddress.textContent = abbreviateAddress(walletPublicKey.toBase58());
    walletControls.style.display = "none";
    walletInfo.style.display = "flex";
    swapBox.hidden = false;
    await updateBalances();
    showNotification("Wallet connected");
  } catch(e) {
    showNotification("Wallet connection failed", "error");
  }
}

async function disconnectWallet() {
  try {
    await wallet.disconnect();
  } catch {}
  walletPublicKey = null;
  walletAddress.textContent = "";
  walletBalance.textContent = "";
  walletControls.style.display = "flex";
  walletInfo.style.display = "none";
  swapBox.hidden = true;
  resetSwapState();
  showNotification("Wallet disconnected");
}

// ---------- MODAL TOKEN SELECTION ---------

function openTokenModal(target) {
  currentModalTarget = target;
  modalBg.style.display = "flex";
  modalSearch.value = "";
  renderTokenList("");
  if (target === "from") {
    tokenFromBtn.setAttribute("aria-expanded", "true");
  } else {
    tokenToBtn.setAttribute("aria-expanded", "true");
  }
  modalSearch.focus();
}

function closeTokenModal() {
  modalBg.style.display = "none";
  tokenFromBtn.setAttribute("aria-expanded", "false");
  tokenToBtn.setAttribute("aria-expanded", "false");
  currentModalTarget = null;
}

function renderTokenList(filter) {
  filter = filter.trim().toLowerCase();
  let filteredTokens = tokens.filter(t => {
    return t.symbol.toLowerCase().includes(filter) || t.name.toLowerCase().includes(filter) || t.address.toLowerCase().includes(filter);
  });
  tokenList.innerHTML = "";
  if(filteredTokens.length === 0) {
    const noResult = document.createElement("div");
    noResult.textContent = "No tokens found";
    noResult.style.padding = "14px";
    noResult.style.textAlign = "center";
    noResult.style.color = "#999";
    tokenList.appendChild(noResult);
    return;
  }
  for (const t of filteredTokens) {
    const item = document.createElement("div");
    item.className = "token-list-item";
    item.tabIndex = 0;
    item.role = "listitem";

    const img = document.createElement("img");
    img.className = "token-list-logo";
    img.src = t.logoURI;
    img.alt = t.symbol + " logo";

    const sym = document.createElement("div");
    sym.className = "token-list-symbol";
    sym.textContent = t.symbol;

    const bal = document.createElement("div");
    bal.className = "token-list-balance";
    bal.textContent = formatAmount(t.balance, 4);

    item.appendChild(img);
    item.appendChild(sym);
    item.appendChild(bal);

    item.addEventListener("click", () => {
      selectToken(t);
      closeTokenModal();
    });
    item.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        selectToken(t);
        closeTokenModal();
      }
    });
    tokenList.appendChild(item);
  }
}

function selectToken(token) {
  if(currentModalTarget === "from") {
    if(selectedTo && token.address === selectedTo.address) {
      showNotification("Token already selected in 'To' slot", "error");
      return;
    }
    selectedFrom = token;
    tokenFromLogo.src = token.logoURI;
    tokenFromSymbol.textContent = token.symbol;
    balanceFromEl.textContent = `Balance: ${formatAmount(token.balance, 4)}`;
  } else if(currentModalTarget === "to") {
    if(selectedFrom && token.address === selectedFrom.address) {
      showNotification("Token already selected in 'From' slot", "error");
      return;
    }
    selectedTo = token;
    tokenToLogo.src = token.logoURI;
    tokenToSymbol.textContent = token.symbol;
    balanceToEl.textContent = `Balance: ${formatAmount(token.balance, 4)}`;
  }
  amountFromInput.value = "";
  amountToInput.value = "";
  rateDisplay.textContent = "Rate: -";
  swapQuote = null;
  updateSwapButtonState();
}

// ----------- SWAP LOGIC & API CALLS -----------

async function getSwapQuote(inputMint, outputMint, inputAmount, slippagePct) {
  if (!inputMint || !outputMint || inputAmount <= 0) return null;

  // Convert inputAmount to base units
  let fromToken = tokens.find(t => t.address === inputMint);
  let toToken = tokens.find(t => t.address === outputMint);
  if (!fromToken || !toToken) return null;

  const inputAmountRaw = Math.floor(inputAmount * Math.pow(10, fromToken.decimals));

  try {
    showLoader(true);
    // Call Jupiter API to get swap routes and best price
    // API doc: https://docs.jup.ag/api/rest-api/api-swap
    // Example endpoint: https://quote-api.jup.ag/v1/quote?inputMint=...&outputMint=...&amount=...&slippageBps=50&onlyDirectRoutes=false

    const slippageBps = Math.floor(slippagePct * 100);
    const url = `https://quote-api.jup.ag/v1/quote?` +
      `inputMint=${inputMint}&outputMint=${outputMint}&amount=${inputAmountRaw}&slippageBps=${slippageBps}&onlyDirectRoutes=false`;

    const response = await fetch(url);
    if (!response.ok) throw new Error("Quote API error");

    const json = await response.json();
    if (!json.data || json.data.length === 0) return null;

    // Take best route (first)
    const bestRoute = json.data[0];

    // Calculate output amount in tokens
    const outputAmountRaw = bestRoute.outAmount;
    const outputAmount = outputAmountRaw / Math.pow(10, toToken.decimals);

    // Return structured quote
    return {
      inputAmount,
      outputAmount,
      priceImpactPct: bestRoute.priceImpactPct || 0,
      routes: bestRoute,
      minOutAmount: bestRoute.outAmountMin,
      tx: bestRoute.swapTransaction, // Base64 encoded tx (needs decode)
      raw: bestRoute
    };
  } catch (e) {
    console.error(e);
    showNotification("Failed to fetch swap quote", "error");
    return null;
  } finally {
    showLoader(false);
  }
}

async function updateQuoteAndUI() {
  if (!selectedFrom || !selectedTo) {
    rateDisplay.textContent = "Rate: -";
    amountToInput.value = "";
    swapQuote = null;
    updateSwapButtonState();
    return;
  }
  const inputAmount = parseFloat(amountFromInput.value);
  if (isNaN(inputAmount) || inputAmount <= 0) {
    rateDisplay.textContent = "Rate: -";
    amountToInput.value = "";
    swapQuote = null;
    updateSwapButtonState();
    return;
  }
  if (inputAmount > selectedFrom.balance) {
    showNotification("Insufficient balance", "error");
    swapQuote = null;
    updateSwapButtonState();
    return;
  }

  const quote = await getSwapQuote(selectedFrom.address, selectedTo.address, inputAmount, slippage);
  if (!quote) {
    rateDisplay.textContent = "Rate: -";
    amountToInput.value = "";
    swapQuote = null;
    updateSwapButtonState();
    return;
  }

  swapQuote = quote;
  amountToInput.value = quote.outputAmount.toFixed(6);
  rateDisplay.textContent = `Rate: 1 ${selectedFrom.symbol} ≈ ${(quote.outputAmount / inputAmount).toFixed(6)} ${selectedTo.symbol}`;
  updateSwapButtonState();
}

function updateSwapButtonState() {
  if (!walletPublicKey) {
    swapBtn.disabled = true;
    return;
  }
  if (!selectedFrom || !selectedTo) {
    swapBtn.disabled = true;
    return;
  }
  const amount = parseFloat(amountFromInput.value);
  if (isNaN(amount) || amount <= 0) {
    swapBtn.disabled = true;
    return;
  }
  if (!swapQuote) {
    swapBtn.disabled = true;
    return;
  }
  swapBtn.disabled = false;
}

async function performSwap() {
  if (!swapQuote) {
    showNotification("No swap quote available", "error");
    return;
  }
  if (!wallet.connected) {
    showNotification("Wallet not connected", "error");
    return;
  }

  try {
    showLoader(true);
    swapBtn.disabled = true;

    // For demo: The swapTransaction from Jupiter is base64 encoded transaction
    // We must decode it, sign it with wallet and send it

    const txBase64 = swapQuote.raw.swapTransaction;
    const rawTx = Uint8Array.from(atob(txBase64), c => c.charCodeAt(0));
    const tx = Transaction.from(rawTx);

    // Replace recent blockhash & feePayer to current wallet (best practice)
    tx.feePayer = wallet.publicKey;
    const { blockhash } = await connection.getRecentBlockhash();
    tx.recentBlockhash = blockhash;

    // Sign transaction with Phantom wallet
    const signedTx = await wallet.signTransaction(tx);

    // Send raw signed transaction
    const txid = await connection.sendRawTransaction(signedTx.serialize());
    showNotification(`Transaction sent: ${txid}`, "success");

    // Wait confirmation
    await connection.confirmTransaction(txid, 'confirmed');
    showNotification(`Swap confirmed: ${txid}`, "success");

    // Refresh balances and reset inputs
    await updateBalances();
    amountFromInput.value = "";
    amountToInput.value = "";
    rateDisplay.textContent = "Rate: -";
    swapQuote = null;
    updateSwapButtonState();

    // Add to history (to be implemented)
  } catch (err) {
    console.error(err);
    showNotification("Swap failed or rejected", "error");
  } finally {
    showLoader(false);
    swapBtn.disabled = false;
  }
}

// ----------- EVENT LISTENERS -----------

connectBtn.addEventListener("click", async () => {
  await connectWallet();
});

disconnectBtn.addEventListener("click", async () => {
  await disconnectWallet();
});

tokenFromBtn.addEventListener("click", () => openTokenModal("from"));
tokenToBtn.addEventListener("click", () => openTokenModal("to"));

modalBg.addEventListener("click", (e) => {
  if (e.target === modalBg) closeTokenModal();
});

modalSearch.addEventListener("input", () => {
  renderTokenList(modalSearch.value);
});

amountFromInput.addEventListener("input", () => {
  updateQuoteAndUI();
});

slippageInput.addEventListener("change", () => {
  let val = parseFloat(slippageInput.value);
  if (isNaN(val) || val < 0) val = 0;
  if (val > 10) val = 10;
  slippage = val;
  slippageInput.value = val.toFixed(2);
  updateQuoteAndUI();
});

swapBtn.addEventListener("click", () => {
  performSwap();
});

// ----------- INITIALIZATION -----------

async function init() {
  showLoader(true);
  await fetchTokenList();
  showLoader(false);

  // Detect if Phantom is installed and auto-connect if authorized
  if (wallet.ready) {
    try {
      await wallet.connect({ onlyIfTrusted: true });
      walletPublicKey = wallet.publicKey;
      walletAddress.textContent = abbreviateAddress(walletPublicKey.toBase58());
      walletControls.style.display = "none";
      walletInfo.style.display = "flex";
      swapBox.hidden = false;
      await updateBalances();
      showNotification("Wallet auto-connected");
    } catch {}
  }

  // Listen to wallet events
  wallet.on("connect", async () => {
    walletPublicKey = wallet.publicKey;
    walletAddress.textContent = abbreviateAddress(walletPublicKey.toBase58());
    walletControls.style.display = "none";
    walletInfo.style.display = "flex";
    swapBox.hidden = false;
    await updateBalances();
    showNotification("Wallet connected");
  });
  wallet.on("disconnect", () => {
    walletPublicKey = null;
    walletAddress.textContent = "";
    walletBalance.textContent = "";
    walletControls.style.display = "flex";
    walletInfo.style.display = "none";
    swapBox.hidden = true;
    resetSwapState();
    showNotification("Wallet disconnected");
  });
}

function resetSwapState() {
  selectedFrom = null;
  selectedTo = null;
  amountFromInput.value = "";
  amountToInput.value = "";
  amountToInput.value = "";
  rateDisplay.textContent = "Rate: -";
  swapQuote = null;
  updateSwapButtonState();
  tokenFromLogo.src = "";
  tokenToLogo.src = "";
  tokenFromSymbol.textContent = "Select Token A";
  tokenToSymbol.textContent = "Select Token B";
  balanceFromEl.textContent = "";
  balanceToEl.textContent = "";
}

init();
</script>

</body>
</html>