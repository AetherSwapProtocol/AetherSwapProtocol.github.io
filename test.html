<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AetherSwap PRO</title>
<style>
  :root {
    --primary: #6e45e2;
    --primary-hover: #5934ba;
    --bg: #0f0f2d;
    --surface: #18182f;
    --text: #eee;
    --text-muted: #bbb;
    --radius: 16px;
    --shadow: 0 8px 32px rgba(0,0,0,0.6);
    --focus: 3px solid var(--primary);
    --transition: 0.3s ease;
  }
  *, *::before, *::after { box-sizing: border-box; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    padding: 24px;
    min-height: 100vh;
  }
  .container {
    background: var(--surface);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    width: min(420px, 100%);
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  h1 {
    margin: 0;
    text-align: center;
    color: var(--primary);
    font-size: 1.6rem;
  }
  .token, .slippage, .btn {
    background: rgba(255, 255, 255, 0.08);
    border-radius: var(--radius);
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: background var(--transition);
  }
  .token:hover, .token:focus {
    background: rgba(110, 69, 226, 0.3);
    outline: var(--focus);
    cursor: pointer;
  }
  .token img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: #fff;
    object-fit: contain;
  }
  input[type=number] {
    flex: 1;
    padding: 8px;
    background: rgba(255, 255, 255, 0.05);
    border: none;
    border-radius: var(--radius);
    color: var(--text);
    font-size: 1rem;
    text-align: right;
  }
  input[readonly] {
    user-select: none;
    cursor: default;
  }
  .switch {
    align-self: center;
    background: none;
    border: none;
    cursor: pointer;
    color: var(--primary);
    padding: 6px;
    width: 36px;
    height: 36px;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: color var(--transition);
  }
  .switch:hover {
    color: var(--primary-hover);
  }
  .btn {
    cursor: pointer;
    background: var(--primary);
    color: #fff;
    font-weight: 700;
    text-align: center;
    border: none;
    padding: 16px;
    border-radius: var(--radius);
    transition: background var(--transition);
  }
  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  .slippage label {
    color: var(--text-muted);
    font-weight: 600;
    min-width: 60px;
  }
  .slippage select, .slippage input {
    background: rgba(255, 255, 255, 0.05);
    border: none;
    border-radius: var(--radius);
    color: var(--text);
    font-size: 1rem;
    padding: 6px 10px;
    width: 100px;
    text-align: right;
  }
  .slippage input {
    display: none;
  }
  .chart-container {
    margin-top: 12px;
  }
  canvas {
    width: 100% !important;
    height: 160px !important;
  }
  .history {
    font-size: 0.9rem;
    max-height: 140px;
    overflow-y: auto;
    color: var(--text-muted);
  }
  .history div {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
  }
  .history a {
    color: var(--primary);
    text-decoration: none;
  }
  .history a:hover {
    text-decoration: underline;
  }
  /* Modal */
  .modal {
    position: fixed;
    inset: 0;
    background: rgba(15, 15, 45, 0.9);
    display: none;
    justify-content: center;
    align-items: flex-start;
    padding: 40px 12px;
    z-index: 1000;
  }
  .modal.active {
    display: flex;
  }
  .modal-content {
    background: var(--surface);
    border-radius: var(--radius);
    width: 100%;
    max-width: 400px;
    box-shadow: var(--shadow);
    padding: 16px;
    color: var(--text);
    position: relative;
  }
  .modal-content h2 {
    margin: 0 0 12px 0;
    color: var(--primary);
  }
  .modal input[type=search] {
    width: 100%;
    padding: 8px;
    border: none;
    border-radius: var(--radius);
    margin-bottom: 12px;
    background: rgba(255, 255, 255, 0.05);
    color: var(--text);
    font-size: 1rem;
  }
  .token-list {
    max-height: 320px;
    overflow-y: auto;
    border-top: 1px solid rgba(255,255,255,0.1);
  }
  .token-list div {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px;
    cursor: pointer;
    border-radius: var(--radius);
    transition: background var(--transition);
  }
  .token-list div:hover {
    background: rgba(110, 69, 226, 0.3);
  }
  .token-list img {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: #fff;
    object-fit: contain;
  }
  .close-btn {
    position: absolute;
    top: 12px;
    right: 16px;
    background: none;
    border: none;
    color: var(--primary);
    font-size: 1.5rem;
    cursor: pointer;
  }
  @media (max-width: 460px) {
    .container {
      padding: 16px;
    }
    canvas {
      height: 120px !important;
    }
  }
</style>
</head>
<body>

<div class="container" role="main" aria-label="AetherSwap PRO">
  <h1>AetherSwap PRO</h1>

  <div class="token" id="fromToken" tabindex="0" aria-label="Select input token">
    <img id="fromIcon" alt="From Token icon" src="" />
    <div id="fromSymbol">Select Token</div>
    <input type="number" id="fromAmt" placeholder="0.0" min="0" step="any" aria-label="Input amount" />
  </div>

  <button class="switch" id="switchBtn" aria-label="Switch tokens" title="Switch tokens">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" viewBox="0 0 24 24">
      <polyline points="17 1 21 5 17 9"/>
      <polyline points="7 15 3 19 7 23"/>
      <line x1="21" y1="5" x2="3" y2="19"/>
    </svg>
  </button>

  <div class="token" id="toToken" tabindex="0" aria-label="Select output token">
    <img id="toIcon" alt="To Token icon" src="" />
    <div id="toSymbol">Select Token</div>
    <input type="number" id="toAmt" placeholder="0.0" readonly aria-label="Output amount" />
  </div>

  <div class="slippage" aria-label="Slippage tolerance settings">
    <label for="slipSelect">Slippage:</label>
    <select id="slipSelect" aria-label="Slippage tolerance">
      <option value="10">0.1%</option>
      <option value="50" selected>0.5%</option>
      <option value="100">1%</option>
      <option value="custom">Custom</option>
    </select>
    <input type="number" id="slipCustom" min="0" max="100" step="0.01" placeholder="%" aria-label="Custom slippage percentage" />
  </div>

  <button class="btn" id="connectBtn">Connect Wallet</button>
  <button class="btn" id="swapBtn" disabled>Swap Now</button>

  <div class="chart-container" aria-label="Price chart">
    <canvas id="priceChart"></canvas>
  </div>

  <div class="history" aria-live="polite" aria-atomic="true" aria-relevant="additions">
    <strong>Swap History</strong>
    <div id="historyList"></div>
  </div>
</div>

<!-- Modal for token selection -->
<div class="modal" id="tokenModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle" tabindex="-1">
  <div class="modal-content">
    <button class="close-btn" id="closeModal" aria-label="Close token selection modal">&times;</button>
    <h2 id="modalTitle">Select a Token</h2>
    <input type="search" id="tokenSearch" placeholder="Search or paste token address..." aria-label="Search or paste token address" autocomplete="off" />
    <div class="token-list" id="tokenList"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.70.1/lib/index.iife.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
<script>
(() => {
  const tokenModal = document.getElementById('tokenModal');
  const tokenListEl = document.getElementById('tokenList');
  const tokenSearch = document.getElementById('tokenSearch');
  const closeModalBtn = document.getElementById('closeModal');

  let tokens = [];
  let filteredTokens = [];
  let currentSelect = null; // 'from' or 'to'

  // Load token list from Jupiter API
  async function loadTokens() {
    try {
      const res = await fetch('https://cache.jup.ag/tokens');
      tokens = await res.json();
      filteredTokens = tokens;
      renderTokenList(filteredTokens);
    } catch (e) {
      console.error('Error loading tokens:', e);
      tokens = [];
      filteredTokens = [];
      tokenListEl.innerHTML = '<p>Failed to load tokens list</p>';
    }
  }

  // Render token list filtered or full
  function renderTokenList(list) {
    tokenListEl.innerHTML = '';
    if (!list.length) {
      tokenListEl.innerHTML = '<p>No tokens found</p>';
      return;
    }
    list.forEach(t => {
      const div = document.createElement('div');
      div.tabIndex = 0;
      div.setAttribute('role', 'button');
      div.setAttribute('aria-label', `Select ${t.symbol} token`);
      div.className = 'token-item';

      const img = document.createElement('img');
      img.src = t.logoURI || '';
      img.alt = t.symbol;
      div.appendChild(img);

      const span = document.createElement('span');
      span.textContent = `${t.symbol} - ${t.name}`;
      div.appendChild(span);

      div.addEventListener('click', () => {
        selectToken(t);
        closeModal();
      });
      div.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          selectToken(t);
          closeModal();
        }
      });

      tokenListEl.appendChild(div);
    });
  }

  // Open modal for a given selection
  function openModal(selection) {
    currentSelect = selection; // 'from' or 'to'
    tokenSearch.value = '';
    filteredTokens = tokens;
    renderTokenList(filteredTokens);
    tokenModal.classList.add('active');
    tokenModal.focus();
  }

  // Close modal
  function closeModal() {
    tokenModal.classList.remove('active');
  }

  // Filter tokens by search or address
  function filterTokens(query) {
    query = query.trim().toLowerCase();
    if (!query) {
      filteredTokens = tokens;
    } else if (query.length === 44 && query.startsWith('So') || query.length === 44) {
      // Possibly paste mint address
      filteredTokens = tokens.filter(t => t.address.toLowerCase() === query);
    } else {
      filteredTokens = tokens.filter(t => 
        t.symbol.toLowerCase().includes(query) ||
        t.name.toLowerCase().includes(query) ||
        t.address.toLowerCase().includes(query)
      );
    }
    renderTokenList(filteredTokens);
  }

  // Select token & update UI
  function selectToken(token) {
    if (!token) return;
    if (currentSelect === 'from') {
      setToken('from', token);
    } else if (currentSelect === 'to') {
      setToken('to', token);
    }
    // Reset amounts on token change
    document.getElementById('fromAmt').value = '';
    document.getElementById('toAmt').value = '';
    swapBtn.disabled = true;
  }

  // Set token UI parts
  function setToken(type, token) {
    const icon = document.getElementById(type + 'Icon');
    const symbol = document.getElementById(type + 'Symbol');
    icon.src = token.logoURI || '';
    icon.alt = token.symbol;
    symbol.textContent = token.symbol;
    tokenState[type] = token;
  }

  // Event listeners
  tokenSearch.addEventListener('input', e => filterTokens(e.target.value));
  closeModalBtn.addEventListener('click', closeModal);
  tokenModal.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeModal();
  });

  // Open modals for selects
  document.getElementById('fromToken').addEventListener('click', () => openModal('from'));
  document.getElementById('toToken').addEventListener('click', () => openModal('to'));
  document.getElementById('fromToken').addEventListener('keydown', e => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      openModal('from');
    }
  });
  document.getElementById('toToken').addEventListener('keydown', e => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      openModal('to');
    }
  });

  // Expose tokens state
  window.tokenState = {
    from: null,
    to: null,
  };

  // Load tokens on start
  loadTokens();

})();
</script>
<script>
(() => {
  const connectBtn = document.getElementById('connectBtn');
  const swapBtn = document.getElementById('swapBtn');
  let wallet = null;
  let provider = null;

  // Phantom detection & connect
  async function connectPhantom() {
    if (window.solana && window.solana.isPhantom) {
      try {
        const resp = await window.solana.connect();
        wallet = window.solana;
        updateUIConnected(wallet.publicKey.toString());
        return wallet.publicKey.toString();
      } catch (e) {
        console.error('Phantom connection error', e);
        alert('Phantom wallet connection rejected or failed.');
      }
    } else {
      alert('Phantom Wallet not detected. Please install Phantom.');
    }
  }

  function updateUIConnected(pubkey) {
    connectBtn.textContent = `Connected: ${pubkey.slice(0,4)}...${pubkey.slice(-4)}`;
    connectBtn.disabled = true;
    swapBtn.disabled = false;
  }

  connectBtn.addEventListener('click', async () => {
    if (!wallet) {
      await connectPhantom();
    }
  });

  window.getWalletPubkey = () => wallet?.publicKey?.toString();

  // Switch tokens button
  const switchBtn = document.getElementById('switchBtn');
  switchBtn.addEventListener('click', () => {
    const temp = window.tokenState.from;
    window.tokenState.from = window.tokenState.to;
    window.tokenState.to = temp;

    // Swap UI
    if (window.tokenState.from) {
      document.getElementById('fromIcon').src = window.tokenState.from.logoURI || '';
      document.getElementById('fromSymbol').textContent = window.tokenState.from.symbol;
    } else {
      document.getElementById('fromIcon').src = '';
      document.getElementById('fromSymbol').textContent = 'Select Token';
    }

    if (window.tokenState.to) {
      document.getElementById('toIcon').src = window.tokenState.to.logoURI || '';
      document.getElementById('toSymbol').textContent = window.tokenState.to.symbol;
    } else {
      document.getElementById('toIcon').src = '';
      document.getElementById('toSymbol').textContent = 'Select Token';
    }

    // Clear amounts
    document.getElementById('fromAmt').value = '';
    document.getElementById('toAmt').value = '';
    swapBtn.disabled = true;
  });

  // Enable swap button when all conditions met
  const fromAmtInput = document.getElementById('fromAmt');
  fromAmtInput.addEventListener('input', () => {
    const fromAmt = parseFloat(fromAmtInput.value);
    if (
      window.tokenState.from &&
      window.tokenState.to &&
      !isNaN(fromAmt) &&
      fromAmt > 0
    ) {
      swapBtn.disabled = false;
    } else {
      swapBtn.disabled = true;
    }
  });
})();
</script>
<script>
(() => {
  const fromAmtInput = document.getElementById('fromAmt');
  const toAmtInput = document.getElementById('toAmt');
  const slipSelect = document.getElementById('slipSelect');
  const slipCustom = document.getElementById('slipCustom');
  const swapBtn = document.getElementById('swapBtn');

  let currentQuote = null;

  // Slippage input toggle
  slipSelect.addEventListener('change', () => {
    if (slipSelect.value === 'custom') {
      slipCustom.style.display = 'inline-block';
      slipCustom.focus();
    } else {
      slipCustom.style.display = 'none';
      slipCustom.value = '';
    }
    triggerQuote();
  });
  slipCustom.addEventListener('input', () => {
    triggerQuote();
  });

  // Debounce helper
  function debounce(func, timeout = 400){
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => { func.apply(this, args); }, timeout);
    };
  }

  // Trigger quote request
  const triggerQuote = debounce(async () => {
    if (
      !window.tokenState.from ||
      !window.tokenState.to
    ) {
      toAmtInput.value = '';
      currentQuote = null;
      return;
    }
    let amount = fromAmtInput.value;
    if (!amount || isNaN(amount) || amount <= 0) {
      toAmtInput.value = '';
      currentQuote = null;
      return;
    }

    const fromMint = window.tokenState.from.address;
    const toMint = window.tokenState.to.address;
    const slippageBps = slipSelect.value === 'custom' && slipCustom.value
      ? Math.floor(parseFloat(slipCustom.value) * 100)
      : parseInt(slipSelect.value);

    try {
      const lamportsAmount = BigInt(Math.floor(parseFloat(amount) * (10 ** window.tokenState.from.decimals)));

      const res = await fetch(`https://lite-api.jup.ag/ultra/v1/quote`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({
          inputMint: fromMint,
          outputMint: toMint,
          amount: lamportsAmount.toString(),
          slippageBps: slippageBps,
          userPublicKey: window.getWalletPubkey() || null,
          // Default swapMode ExactIn
          swapMode: "ExactIn"
        })
      });
      if(!res.ok) throw new Error('Quote API error');

      const json = await res.json();
      if(json.error) throw new Error(json.error);

      currentQuote = json;
      if (json.outAmount) {
        const outAmountNum = Number(json.outAmount) / 10 ** window.tokenState.to.decimals;
        toAmtInput.value = outAmountNum.toFixed(6);
      } else {
        toAmtInput.value = '';
      }
    } catch (e) {
      console.error('Quote fetch error', e);
      currentQuote = null;
      toAmtInput.value = '';
    }
  }, 600);

  // Trigger quote on input or token change
  fromAmtInput.addEventListener('input', triggerQuote);
  slipSelect.addEventListener('change', triggerQuote);
  slipCustom.addEventListener('input', triggerQuote);

  // Also trigger quote when tokens change (using MutationObserver on symbols)
  const observer = new MutationObserver(triggerQuote);
  observer.observe(document.getElementById('fromSymbol'), {childList: true});
  observer.observe(document.getElementById('toSymbol'), {childList: true});
})();
</script>
<script>
(() => {
  const swapBtn = document.getElementById('swapBtn');
  const connectBtn = document.getElementById('connectBtn');
  const historyList = document.getElementById('historyList');

  // Save swap history in localStorage
  function saveHistory(entry) {
    let history = JSON.parse(localStorage.getItem('swapHistory') || '[]');
    history.unshift(entry);
    if(history.length > 20) history.pop();
    localStorage.setItem('swapHistory', JSON.stringify(history));
  }
  // Load swap history from localStorage
  function loadHistory() {
    let history = JSON.parse(localStorage.getItem('swapHistory') || '[]');
    historyList.innerHTML = '';
    history.forEach(item => {
      const div = document.createElement('div');
      div.innerHTML = `
        <div>
          <span>${item.fromSymbol} → ${item.toSymbol}</span>
          <a href="https://solscan.io/tx/${item.txid}" target="_blank" rel="noopener noreferrer" aria-label="View transaction on Solscan">${item.txid.slice(0, 6)}...${item.txid.slice(-6)}</a>
        </div>
      `;
      historyList.appendChild(div);
    });
  }
  loadHistory();

  swapBtn.addEventListener('click', async () => {
    if (!window.tokenState.from || !window.tokenState.to) {
      alert('Please select tokens.');
      return;
    }
    if (!window.getWalletPubkey()) {
      alert('Please connect your wallet.');
      return;
    }
    if (!currentQuote || !currentQuote.swapTransaction) {
      alert('No valid quote available.');
      return;
    }

    swapBtn.disabled = true;
    swapBtn.textContent = 'Processing...';

    try {
      const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl('mainnet-beta'), 'confirmed');
      const txBuffer = Buffer.from(currentQuote.swapTransaction, 'base64');
      const transaction = solanaWeb3.Transaction.from(txBuffer);

      transaction.feePayer = new solanaWeb3.PublicKey(window.getWalletPubkey());
      const { blockhash } = await connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;

      // Sign transaction with Phantom
      const signedTx = await window.solana.signTransaction(transaction);
      const txid = await connection.sendRawTransaction(signedTx.serialize());
      await connection.confirmTransaction(txid);

      saveHistory({
        txid,
        fromSymbol: window.tokenState.from.symbol,
        toSymbol: window.tokenState.to.symbol,
        timestamp: Date.now(),
      });

      loadHistory();
      alert(`Swap successful! Transaction ID: ${txid}`);

    } catch (e) {
      console.error('Swap error:', e);
      alert('Swap failed: ' + (e.message || e));
    } finally {
      swapBtn.textContent = 'Swap Now';
      swapBtn.disabled = false;
    }
  });
})();
</script>
<script>
(() => {
  const ctx = document.getElementById('priceChart').getContext('2d');
  let chart = null;

  async function fetchPriceHistory(inputMint, outputMint) {
    try {
      // Placeholder API call, adapt if Jupiter API offers price history
      // Using Coingecko or any public API would be ideal, here dummy data
      // For demo, generate random data for 24 points (hours)
      let labels = [];
      let data = [];
      for(let i=23; i>=0; i--) {
        labels.push(`${i}h`);
        data.push((Math.random() * 10 + 1).toFixed(4));
      }
      return { labels, data };
    } catch(e) {
      console.error('Price history error', e);
      return null;
    }
  }

  async function updateChart() {
    if (!window.tokenState.from || !window.tokenState.to) {
      if(chart) {
        chart.destroy();
        chart = null;
      }
      return;
    }
    const history = await fetchPriceHistory(window.tokenState.from.address, window.tokenState.to.address);
    if(!history) return;

    if(chart) chart.destroy();

    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: history.labels,
        datasets: [{
          label: `${window.tokenState.from.symbol}/${window.tokenState.to.symbol}`,
          data: history.data,
          borderColor: 'rgba(110,69,226,0.8)',
          backgroundColor: 'rgba(110,69,226,0.3)',
          fill: true,
          tension: 0.3,
          pointRadius: 0,
          borderWidth: 2,
        }]
      },
      options: {
        responsive: true,
        animation: { duration: 500 },
        scales: {
          y: {
            beginAtZero: false,
            ticks: { color: '#ccc' }
          },
          x: {
            ticks: { color: '#ccc' }
          }
        },
        plugins: {
          legend: {
            labels: { color: '#ddd' }
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        }
      }
    });
  }

  // Update chart on token changes
  const fromSymbolEl = document.getElementById('fromSymbol');
  const toSymbolEl = document.getElementById('toSymbol');
  const observer = new MutationObserver(() => {
    updateChart();
  });
  observer.observe(fromSymbolEl, { childList: true });
  observer.observe(toSymbolEl, { childList: true });

  // Also update chart on page load and after token load
  window.addEventListener('load', () => {
    updateChart();
  });
})();

</script>

</body>
</html>