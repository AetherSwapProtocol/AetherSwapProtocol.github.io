<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swap Kombat Ultra Premium</title>
  <style>
    :root {
      --primary: #ff6b00;
      --secondary: #ffd700;
      --dark: #121212;
      --darker: #0a0a0a;
      --light: #ffffff;
      --success: #00ff88;
      --danger: #ff3860;
      --info: #3298dc;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
    }
    
    body {
      background: var(--dark);
      color: var(--light);
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    header {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--darker);
      padding: 1rem;
      text-align: center;
      font-size: 1.8rem;
      font-weight: 800;
      letter-spacing: 1px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      position: relative;
      z-index: 10;
    }
    
    #game-container {
      flex: 1;
      display: flex;
      position: relative;
      overflow: hidden;
    }
    
    #main-canvas {
      flex: 1;
      background: radial-gradient(ellipse at center, #1a1a1a 0%, #0a0a0a 100%);
      display: block;
      image-rendering: pixelated;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      padding: 1rem;
    }
    
    #hud {
      background: rgba(0,0,0,0.7);
      border-radius: 12px;
      padding: 1rem;
      width: 220px;
      border: 2px solid var(--primary);
      box-shadow: 0 0 15px rgba(255,107,0,0.3);
      margin-bottom: 1rem;
    }
    
    .hud-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }
    
    .hud-label {
      color: var(--secondary);
      font-weight: 600;
    }
    
    .hud-value {
      font-weight: 700;
    }
    
    #wallet-btn {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--darker);
      border: none;
      padding: 0.8rem 1.2rem;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      transition: all 0.2s;
      pointer-events: auto;
      align-self: flex-end;
    }
    
    #wallet-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    
    #wallet-btn:active {
      transform: translateY(0);
    }
    
    #combat-log {
      background: rgba(30,30,30,0.9);
      border-radius: 8px;
      padding: 1rem;
      margin-top: auto;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #333;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      line-height: 1.4;
      pointer-events: auto;
    }
    
    .log-entry {
      margin-bottom: 0.3rem;
      animation: fadeIn 0.3s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    #enemy-health-bar {
      height: 20px;
      background: var(--danger);
      border-radius: 10px;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(255,56,96,0.5);
    }
    
    #player-health-bar {
      height: 20px;
      background: var(--success);
      border-radius: 10px;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(0,255,136,0.5);
    }
    
    #skill-buttons {
      position: absolute;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      pointer-events: auto;
    }
    
    .skill-btn {
      background: rgba(50,152,220,0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .skill-btn:hover {
      transform: scale(1.1);
      background: rgba(50,152,220,1);
    }
    
    .skill-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    #game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    
    .modal {
      background: var(--darker);
      border-radius: 12px;
      padding: 2rem;
      max-width: 500px;
      width: 90%;
      border: 2px solid var(--primary);
      box-shadow: 0 0 30px rgba(255,107,0,0.5);
      text-align: center;
    }
    
    .modal h2 {
      color: var(--secondary);
      margin-bottom: 1rem;
      font-size: 2rem;
    }
    
    .modal p {
      margin-bottom: 1.5rem;
      line-height: 1.6;
    }
    
    .btn {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--darker);
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0.5rem;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    #inventory {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(0,0,0,0.7);
      border-radius: 12px;
      padding: 1rem;
      width: 200px;
      border: 2px solid var(--secondary);
      box-shadow: 0 0 15px rgba(255,215,0,0.3);
      display: none;
    }
    
    #inventory h3 {
      color: var(--secondary);
      margin-bottom: 0.5rem;
      text-align: center;
    }
    
    .item {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      border-bottom: 1px solid #333;
    }
    
    .item:last-child {
      border-bottom: none;
    }
    
    .item-name {
      color: var(--light);
    }
    
    .item-count {
      color: var(--secondary);
      font-weight: 700;
    }
    
    .xp-bar-container {
      height: 10px;
      background: #333;
      border-radius: 5px;
      margin: 0.5rem 0;
      overflow: hidden;
    }
    
    #xp-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      width: 0%;
      transition: width 0.5s ease;
    }
    
    /* Animations */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    
    .shake {
      animation: shake 0.5s;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .pulse {
      animation: pulse 0.5s;
    }
    
    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    .flash {
      animation: flash 0.5s;
    }
  </style>
</head>
<body>
  <header>
    <span>‚öîÔ∏è</span> SWAP KOMBAT ULTRA <span>‚öîÔ∏è</span>
  </header>
  
  <div id="game-container">
    <canvas id="main-canvas"></canvas>
    
    <div id="ui-overlay">
      <div id="hud">
        <div class="hud-row">
          <span class="hud-label">Niveau:</span>
          <span id="level-value" class="hud-value">1</span>
        </div>
        <div class="hud-row">
          <span class="hud-label">XP:</span>
          <span id="xp-value" class="hud-value">0/100</span>
        </div>
        <div class="xp-bar-container">
          <div id="xp-bar"></div>
        </div>
        <div class="hud-row">
          <span class="hud-label">Vie:</span>
          <span id="health-value" class="hud-value">100/100</span>
        </div>
        <div id="player-health-bar" style="width: 100%"></div>
        <div class="hud-row">
          <span class="hud-label">√ânergie:</span>
          <span id="energy-value" class="hud-value">50/100</span>
        </div>
        <div class="hud-row">
          <span class="hud-label">Tokens:</span>
          <span id="tokens-value" class="hud-value">0</span>
        </div>
      </div>
      
      <button id="wallet-btn">Connecter Wallet</button>
      
      <div id="combat-log">
        <div class="log-entry">Bienvenue dans Swap Kombat Ultra!</div>
        <div class="log-entry">Cliquez sur l'ennemi pour attaquer.</div>
      </div>
    </div>
    
    <div id="skill-buttons">
      <button class="skill-btn" id="basic-attack">‚öîÔ∏è</button>
      <button class="skill-btn" id="special-attack">üî•</button>
      <button class="skill-btn" id="heal">‚ù§Ô∏è</button>
      <button class="skill-btn" id="inventory-btn">üéí</button>
    </div>
    
    <div id="inventory">
      <h3>Inventaire</h3>
      <div class="item">
        <span class="item-name">Potion de vie</span>
        <span id="health-potion-count" class="item-count">0</span>
      </div>
      <div class="item">
        <span class="item-name">Potion d'√©nergie</span>
        <span id="energy-potion-count" class="item-count">0</span>
      </div>
      <div class="item">
        <span class="item-name">Boost d'XP</span>
        <span id="xp-boost-count" class="item-count">0</span>
      </div>
      <button id="use-health-potion" class="btn" style="margin-top: 0.5rem; padding: 0.3rem 0.6rem; font-size: 0.8rem;">Utiliser Potion</button>
    </div>
    
    <div id="game-overlay" style="display: none;">
      <div class="modal">
        <h2 id="modal-title">Game Over</h2>
        <p id="modal-message">Vous avez √©t√© vaincu!</p>
        <button id="restart-btn" class="btn">Recommencer</button>
      </div>
    </div>
  </div>

  <script>
    // Configuration du jeu
    const config = {
      canvasWidth: 800,
      canvasHeight: 500,
      player: {
        baseHealth: 100,
        baseEnergy: 50,
        baseDamage: 10,
        specialDamage: 25,
        specialCost: 30,
        healAmount: 30,
        healCost: 20,
        energyRegen: 1,
        xpPerLevel: 100,
        tokensPerLevel: 50
      },
      enemy: {
        baseHealth: 150,
        baseDamage: 8,
        spawnInterval: 10000, // 10 secondes
        healthIncreasePerLevel: 20,
        damageIncreasePerLevel: 2
      },
      items: {
        healthPotion: { heal: 30, price: 20 },
        energyPotion: { restore: 40, price: 15 },
        xpBoost: { multiplier: 1.5, duration: 30000, price: 30 } // 30 secondes
      }
    };

    // √âl√©ments du DOM
    const elements = {
      canvas: document.getElementById('main-canvas'),
      ctx: document.getElementById('main-canvas').getContext('2d'),
      levelValue: document.getElementById('level-value'),
      xpValue: document.getElementById('xp-value'),
      xpBar: document.getElementById('xp-bar'),
      healthValue: document.getElementById('health-value'),
      playerHealthBar: document.getElementById('player-health-bar'),
      energyValue: document.getElementById('energy-value'),
      tokensValue: document.getElementById('tokens-value'),
      combatLog: document.getElementById('combat-log'),
      walletBtn: document.getElementById('wallet-btn'),
      basicAttackBtn: document.getElementById('basic-attack'),
      specialAttackBtn: document.getElementById('special-attack'),
      healBtn: document.getElementById('heal'),
      inventoryBtn: document.getElementById('inventory-btn'),
      inventory: document.getElementById('inventory'),
      healthPotionCount: document.getElementById('health-potion-count'),
      energyPotionCount: document.getElementById('energy-potion-count'),
      xpBoostCount: document.getElementById('xp-boost-count'),
      useHealthPotionBtn: document.getElementById('use-health-potion'),
      gameOverlay: document.getElementById('game-overlay'),
      modalTitle: document.getElementById('modal-title'),
      modalMessage: document.getElementById('modal-message'),
      restartBtn: document.getElementById('restart-btn')
    };

    // √âtat du jeu
    const gameState = {
      player: {
        health: config.player.baseHealth,
        maxHealth: config.player.baseHealth,
        energy: config.player.baseEnergy,
        maxEnergy: 100,
        level: 1,
        xp: 0,
        tokens: 0,
        xpMultiplier: 1,
        wallet: null,
        isXpBoosted: false,
        xpBoostEndTime: 0
      },
      enemy: {
        health: 0,
        maxHealth: 0,
        damage: 0,
        level: 0,
        isActive: false,
        spawnTimer: 0
      },
      items: {
        healthPotions: 0,
        energyPotions: 0,
        xpBoosts: 0
      },
      gameTime: 0,
      isGameOver: false,
      lastFrameTime: 0,
      animations: [],
      particles: []
    };

    // Initialisation du jeu
    function initGame() {
      // Configuration du canvas
      elements.canvas.width = config.canvasWidth;
      elements.canvas.height = config.canvasHeight;
      
      // R√©initialisation de l'√©tat du jeu
      Object.assign(gameState, {
        player: {
          health: config.player.baseHealth,
          maxHealth: config.player.baseHealth,
          energy: config.player.baseEnergy,
          maxEnergy: 100,
          level: 1,
          xp: 0,
          tokens: 0,
          xpMultiplier: 1,
          wallet: null,
          isXpBoosted: false,
          xpBoostEndTime: 0
        },
        enemy: {
          health: 0,
          maxHealth: 0,
          damage: 0,
          level: 0,
          isActive: false,
          spawnTimer: 0
        },
        items: {
          healthPotions: 0,
          energyPotions: 0,
          xpBoosts: 0
        },
        gameTime: 0,
        isGameOver: false,
        lastFrameTime: 0,
        animations: [],
        particles: []
      });
      
      // Spawn du premier ennemi
      spawnEnemy();
      
      // Mise √† jour de l'UI
      updateUI();
      
      // Masquer l'overlay de fin de jeu
      elements.gameOverlay.style.display = 'none';
      
      // Ajouter un message de bienvenue
      addLogMessage("Un ennemi appara√Æt!");
      
      // D√©marrer la boucle de jeu
      requestAnimationFrame(gameLoop);
    }

    // Fonction pour faire appara√Ætre un nouvel ennemi
    function spawnEnemy() {
      gameState.enemy.level = gameState.player.level;
      gameState.enemy.maxHealth = config.enemy.baseHealth + (gameState.enemy.level - 1) * config.enemy.healthIncreasePerLevel;
      gameState.enemy.health = gameState.enemy.maxHealth;
      gameState.enemy.damage = config.enemy.baseDamage + (gameState.enemy.level - 1) * config.enemy.damageIncreasePerLevel;
      gameState.enemy.isActive = true;
      gameState.enemy.spawnTimer = 0;
      
      addLogMessage(`Un ennemi niveau ${gameState.enemy.level} appara√Æt!`);
      addAnimation('enemy-spawn', { x: elements.canvas.width / 2, y: 150 }, 1000);
    }

    // Fonction d'attaque de base
    function basicAttack() {
      if (gameState.player.energy < 10) {
        addLogMessage("Pas assez d'√©nergie!", "danger");
        return;
      }
      
      if (!gameState.enemy.isActive) {
        addLogMessage("Aucun ennemi √† attaquer!", "warning");
        return;
      }
      
      // D√©penser de l'√©nergie
      gameState.player.energy -= 10;
      
      // Calculer les d√©g√¢ts
      const damage = config.player.baseDamage + Math.floor(Math.random() * 5);
      
      // Infliger des d√©g√¢ts √† l'ennemi
      gameState.enemy.health -= damage;
      if (gameState.enemy.health < 0) gameState.enemy.health = 0;
      
      // Ajouter des effets visuels
      addAnimation('basic-attack', { x: elements.canvas.width / 2, y: 150 }, 500);
      addParticles(elements.canvas.width / 2, 150, 10, '#ff6b00');
      
      // Ajouter un message de log
      addLogMessage(`Attaque de base! -${damage} PV`, "success");
      
      // V√©rifier si l'ennemi est mort
      if (gameState.enemy.health <= 0) {
        enemyDefeated();
      } else {
        // L'ennemi contre-attaque
        setTimeout(enemyAttack, 500);
      }
      
      updateUI();
    }

    // Fonction d'attaque sp√©ciale
    function specialAttack() {
      if (gameState.player.energy < config.player.specialCost) {
        addLogMessage(`Pas assez d'√©nergie! (n√©cessite ${config.player.specialCost})`, "danger");
        return;
      }
      
      if (!gameState.enemy.isActive) {
        addLogMessage("Aucun ennemi √† attaquer!", "warning");
        return;
      }
      
      // D√©penser de l'√©nergie
      gameState.player.energy -= config.player.specialCost;
      
      // Calculer les d√©g√¢ts
      const damage = config.player.specialDamage + Math.floor(Math.random() * 10);
      
      // Infliger des d√©g√¢ts √† l'ennemi
      gameState.enemy.health -= damage;
      if (gameState.enemy.health < 0) gameState.enemy.health = 0;
      
      // Ajouter des effets visuels
      addAnimation('special-attack', { x: elements.canvas.width / 2, y: 150 }, 800);
      addParticles(elements.canvas.width / 2, 150, 20, '#ff0000');
      
      // Ajouter un message de log
      addLogMessage(`Attaque sp√©ciale! -${damage} PV`, "success");
      
      // V√©rifier si l'ennemi est mort
      if (gameState.enemy.health <= 0) {
        enemyDefeated();
      } else {
        // L'ennemi contre-attaque
        setTimeout(enemyAttack, 500);
      }
      
      updateUI();
    }

    // Fonction de soin
    function heal() {
      if (gameState.player.energy < config.player.healCost) {
        addLogMessage(`Pas assez d'√©nergie! (n√©cessite ${config.player.healCost})`, "danger");
        return;
      }
      
      if (gameState.player.health >= gameState.player.maxHealth) {
        addLogMessage("Vie d√©j√† au maximum!", "warning");
        return;
      }
      
      // D√©penser de l'√©nergie
      gameState.player.energy -= config.player.healCost;
      
      // Soigner le joueur
      gameState.player.health += config.player.healAmount;
      if (gameState.player.health > gameState.player.maxHealth) {
        gameState.player.health = gameState.player.maxHealth;
      }
      
      // Ajouter des effets visuels
      addAnimation('heal', { x: 100, y: elements.canvas.height - 100 }, 800);
      addParticles(100, elements.canvas.height - 100, 15, '#00ff88');
      
      // Ajouter un message de log
      addLogMessage(`Soin! +${config.player.healAmount} PV`, "success");
      
      updateUI();
    }

    // Fonction d'attaque de l'ennemi
    function enemyAttack() {
      if (!gameState.enemy.isActive || gameState.isGameOver) return;
      
      // Calculer les d√©g√¢ts
      const damage = gameState.enemy.damage + Math.floor(Math.random() * 5);
      
      // Infliger des d√©g√¢ts au joueur
      gameState.player.health -= damage;
      if (gameState.player.health < 0) gameState.player.health = 0;
      
      // Ajouter des effets visuels
      addAnimation('enemy-attack', { x: 100, y: elements.canvas.height - 100 }, 500);
      addParticles(100, elements.canvas.height - 100, 10, '#ff3860');
      
      // Ajouter un message de log
      addLogMessage(`L'ennemi attaque! -${damage} PV`, "danger");
      
      // Secouer l'√©cran pour l'effet d'impact
      elements.canvas.classList.add('shake');
      setTimeout(() => elements.canvas.classList.remove('shake'), 500);
      
      // V√©rifier si le joueur est mort
      if (gameState.player.health <= 0) {
        gameOver();
      }
      
      updateUI();
    }

    // Fonction appel√©e quand un ennemi est vaincu
    function enemyDefeated() {
      gameState.enemy.isActive = false;
      
      // Calculer l'XP gagn√©e
      const xpGained = Math.floor((20 + gameState.enemy.level * 5) * gameState.player.xpMultiplier);
      gameState.player.xp += xpGained;
      
      // Calculer les tokens gagn√©s
      const tokensGained = 10 + gameState.enemy.level * 2;
      gameState.player.tokens += tokensGained;
      
      // Ajouter des effets visuels
      addAnimation('enemy-defeated', { x: elements.canvas.width / 2, y: 150 }, 1000);
      addParticles(elements.canvas.width / 2, 150, 30, '#ffd700');
      
      // Ajouter un message de log
      addLogMessage(`Ennemi vaincu! +${xpGained} XP, +${tokensGained} tokens`, "success");
      
      // V√©rifier si le joueur a gagn√© un niveau
      checkLevelUp();
      
      // Planifier l'apparition d'un nouvel ennemi
      gameState.enemy.spawnTimer = config.enemy.spawnInterval;
      
      updateUI();
    }

    // Fonction pour v√©rifier si le joueur monte de niveau
    function checkLevelUp() {
      const xpNeeded = gameState.player.level * config.player.xpPerLevel;
      
      if (gameState.player.xp >= xpNeeded) {
        gameState.player.level++;
        gameState.player.xp -= xpNeeded;
        gameState.player.tokens += config.player.tokensPerLevel;
        gameState.player.maxHealth = config.player.baseHealth + (gameState.player.level - 1) * 10;
        gameState.player.health = gameState.player.maxHealth;
        gameState.player.maxEnergy = 100;
        gameState.player.energy = gameState.player.maxEnergy;
        
        // Ajouter des effets visuels
        addAnimation('level-up', { x: 100, y: elements.canvas.height - 100 }, 1500);
        addParticles(100, elements.canvas.height - 100, 50, '#3298dc');
        
        // Ajouter un message de log
        addLogMessage(`Niveau ${gameState.player.level} atteint! +${config.player.tokensPerLevel} tokens`, "info");
        
        // V√©rifier √† nouveau au cas o√π il aurait assez d'XP pour plusieurs niveaux
        checkLevelUp();
      }
      
      updateUI();
    }

    // Fonction de fin de jeu
    function gameOver() {
      gameState.isGameOver = true;
      
      // Afficher l'√©cran de fin de jeu
      elements.modalTitle.textContent = "Game Over";
      elements.modalMessage.textContent = `Vous avez √©t√© vaincu au niveau ${gameState.player.level}!`;
      elements.gameOverlay.style.display = 'flex';
      
      // Ajouter un message de log
      addLogMessage("Game Over! Cliquez sur Recommencer pour rejouer.", "danger");
    }

    // Fonction pour ajouter un message au journal de combat
    function addLogMessage(message, type = "normal") {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = message;
      
      // Appliquer des styles en fonction du type de message
      switch (type) {
        case "success":
          entry.style.color = '#00ff88';
          break;
        case "danger":
          entry.style.color = '#ff3860';
          break;
        case "warning":
          entry.style.color = '#ffd700';
          break;
        case "info":
          entry.style.color = '#3298dc';
          break;
      }
      
      elements.combatLog.appendChild(entry);
      
      // Faire d√©filer vers le bas
      elements.combatLog.scrollTop = elements.combatLog.scrollHeight;
      
      // Supprimer les anciens messages si trop nombreux
      while (elements.combatLog.children.length > 50) {
        elements.combatLog.removeChild(elements.combatLog.firstChild);
      }
    }

    // Fonction pour mettre √† jour l'interface utilisateur
    function updateUI() {
      // Mettre √† jour les valeurs du HUD
      elements.levelValue.textContent = gameState.player.level;
      elements.xpValue.textContent = `${gameState.player.xp}/${gameState.player.level * config.player.xpPerLevel}`;
      elements.xpBar.style.width = `${(gameState.player.xp / (gameState.player.level * config.player.xpPerLevel)) * 100}%`;
      elements.healthValue.textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
      elements.playerHealthBar.style.width = `${(gameState.player.health / gameState.player.maxHealth) * 100}%`;
      elements.energyValue.textContent = `${gameState.player.energy}/${gameState.player.maxEnergy}`;
      elements.tokensValue.textContent = gameState.player.tokens;
      
      // Mettre √† jour l'inventaire
      elements.healthPotionCount.textContent = gameState.items.healthPotions;
      elements.energyPotionCount.textContent = gameState.items.energyPotions;
      elements.xpBoostCount.textContent = gameState.items.xpBoosts;
      
      // Activer/d√©sactiver les boutons en fonction de l'√©nergie disponible
      elements.basicAttackBtn.disabled = gameState.player.energy < 10;
      elements.specialAttackBtn.disabled = gameState.player.energy < config.player.specialCost;
      elements.healBtn.disabled = gameState.player.energy < config.player.healCost || gameState.player.health >= gameState.player.maxHealth;
      
      // Mettre √† jour le bouton du wallet
      if (gameState.player.wallet) {
        elements.walletBtn.textContent = `Wallet: ${gameState.player.wallet.substring(0, 6)}...${gameState.player.wallet.substring(gameState.player.wallet.length - 4)}`;
      } else {
        elements.walletBtn.textContent = "Connecter Wallet";
      }
    }

    // Fonction pour ajouter une animation
    function addAnimation(type, position, duration) {
      const animation = {
        type,
        position,
        startTime: gameState.gameTime,
        duration,
        progress: 0
      };
      
      gameState.animations.push(animation);
    }

    // Fonction pour ajouter des particules
    function addParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        const size = 2 + Math.random() * 4;
        const lifetime = 500 + Math.random() * 1000;
        
        gameState.particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size,
          color,
          startTime: gameState.gameTime,
          lifetime,
          alpha: 1
        });
      }
    }

    // Fonction pour utiliser une potion de vie
    function useHealthPotion() {
      if (gameState.items.healthPotions <= 0) {
        addLogMessage("Pas de potions de vie disponibles!", "warning");
        return;
      }
      
      if (gameState.player.health >= gameState.player.maxHealth) {
        addLogMessage("Vie d√©j√† au maximum!", "warning");
        return;
      }
      
      // Utiliser une potion
      gameState.items.healthPotions--;
      
      // Soigner le joueur
      const healAmount = config.items.healthPotion.heal;
      gameState.player.health += healAmount;
      if (gameState.player.health > gameState.player.maxHealth) {
        gameState.player.health = gameState.player.maxHealth;
      }
      
      // Ajouter des effets visuels
      addAnimation('potion-use', { x: 100, y: elements.canvas.height - 100 }, 800);
      addParticles(100, elements.canvas.height - 100, 20, '#00ff88');
      
      // Ajouter un message de log
      addLogMessage(`Potion de vie utilis√©e! +${healAmount} PV`, "success");
      
      updateUI();
    }

    // Fonction pour utiliser un boost d'XP
    function useXpBoost() {
      if (gameState.items.xpBoosts <= 0) {
        addLogMessage("Pas de boosts d'XP disponibles!", "warning");
        return;
      }
      
      if (gameState.player.isXpBoosted) {
        addLogMessage("Boost d'XP d√©j√† actif!", "warning");
        return;
      }
      
      // Utiliser un boost
      gameState.items.xpBoosts--;
      
      // Activer le boost
      gameState.player.xpMultiplier = config.items.xpBoost.multiplier;
      gameState.player.isXpBoosted = true;
      gameState.player.xpBoostEndTime = gameState.gameTime + config.items.xpBoost.duration;
      
      // Ajouter des effets visuels
      addAnimation('xp-boost', { x: 100, y: elements.canvas.height - 100 }, 1500);
      addParticles(100, elements.canvas.height - 100, 30, '#3298dc');
      
      // Ajouter un message de log
      addLogMessage(`Boost d'XP activ√©! XP x${config.items.xpBoost.multiplier} pendant ${config.items.xpBoost.duration / 1000} secondes`, "info");
      
      updateUI();
    }

    // Fonction pour acheter un item
    function buyItem(itemType) {
      const item = config.items[itemType];
      
      if (gameState.player.tokens < item.price) {
        addLogMessage(`Pas assez de tokens! (n√©cessite ${item.price})`, "danger");
        return;
      }
      
      // D√©penser les tokens
      gameState.player.tokens -= item.price;
      
      // Ajouter l'item √† l'inventaire
      switch (itemType) {
        case 'healthPotion':
          gameState.items.healthPotions++;
          break;
        case 'energyPotion':
          gameState.items.energyPotions++;
          break;
        case 'xpBoost':
          gameState.items.xpBoosts++;
          break;
      }
      
      // Ajouter un message de log
      addLogMessage(`${getItemName(itemType)} achet√©!`, "success");
      
      updateUI();
    }

    // Fonction pour obtenir le nom d'un item
    function getItemName(itemType) {
      switch (itemType) {
        case 'healthPotion': return 'Potion de vie';
        case 'energyPotion': return 'Potion d\'√©nergie';
        case 'xpBoost': return 'Boost d\'XP';
        default: return 'Item';
      }
    }

    // Fonction pour simuler la connexion d'un wallet
    function connectWallet() {
      if (gameState.player.wallet) {
      // If wallet is already connected, show message
      addLogMessage("Wallet d√©j√† connect√©!", "info");
      return;
    }
    
    // Simulate wallet connection (in a real app, this would use Web3 or similar)
    const walletAddress = generateWalletAddress();
    gameState.player.wallet = walletAddress;
    
    // Add some bonus tokens for connecting wallet
    const bonusTokens = 100;
    gameState.player.tokens += bonusTokens;
    
    // Add log message
    addLogMessage(`Wallet connect√©! +${bonusTokens} tokens bonus`, "success");
    
    // Update UI
    updateUI();
  }

  // Helper function to generate a fake wallet address
  function generateWalletAddress() {
    const chars = '0123456789abcdef';
    let result = '0x';
    for (let i = 0; i < 40; i++) {
      result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
  }

  // Main game loop
  function gameLoop(timestamp) {
    if (!gameState.lastFrameTime) gameState.lastFrameTime = timestamp;
    const deltaTime = timestamp - gameState.lastFrameTime;
    gameState.lastFrameTime = timestamp;
    gameState.gameTime += deltaTime;
    
    // Clear canvas
    elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
    
    // Draw background
    drawBackground();
    
    // Update and draw animations
    updateAnimations(deltaTime);
    
    // Update and draw particles
    updateParticles(deltaTime);
    
    // Draw player
    drawPlayer();
    
    // Draw enemy if active
    if (gameState.enemy.isActive) {
      drawEnemy();
    }
    
    // Handle enemy spawning
    if (!gameState.enemy.isActive && !gameState.isGameOver) {
      gameState.enemy.spawnTimer -= deltaTime;
      if (gameState.enemy.spawnTimer <= 0) {
        spawnEnemy();
      }
    }
    
    // Regenerate player energy
    if (!gameState.isGameOver) {
      gameState.player.energy += config.player.energyRegen * (deltaTime / 1000);
      if (gameState.player.energy > gameState.player.maxEnergy) {
        gameState.player.energy = gameState.player.maxEnergy;
      }
    }
    
    // Check if XP boost has expired
    if (gameState.player.isXpBoosted && gameState.gameTime >= gameState.player.xpBoostEndTime) {
      gameState.player.xpMultiplier = 1;
      gameState.player.isXpBoosted = false;
      addLogMessage("Boost d'XP termin√©", "warning");
    }
    
    // Update UI if needed
    updateUI();
    
    // Continue the game loop
    if (!gameState.isGameOver) {
      requestAnimationFrame(gameLoop);
    }
  }

  // Function to draw background
  function drawBackground() {
    // Draw gradient background
    const gradient = elements.ctx.createRadialGradient(
      elements.canvas.width / 2, elements.canvas.height / 2, 0,
      elements.canvas.width / 2, elements.canvas.height / 2, elements.canvas.width / 2
    );
    gradient.addColorStop(0, '#1a1a1a');
    gradient.addColorStop(1, '#0a0a0a');
    
    elements.ctx.fillStyle = gradient;
    elements.ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);
    
    // Draw grid pattern
    elements.ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
    elements.ctx.lineWidth = 1;
    
    for (let x = 0; x < elements.canvas.width; x += 40) {
      elements.ctx.beginPath();
      elements.ctx.moveTo(x, 0);
      elements.ctx.lineTo(x, elements.canvas.height);
      elements.ctx.stroke();
    }
    
    for (let y = 0; y < elements.canvas.height; y += 40) {
      elements.ctx.beginPath();
      elements.ctx.moveTo(0, y);
      elements.ctx.lineTo(elements.canvas.width, y);
      elements.ctx.stroke();
    }
  }

  // Function to draw player
  function drawPlayer() {
    const x = 100;
    const y = elements.canvas.height - 100;
    const size = 60;
    
    // Draw shadow
    elements.ctx.beginPath();
    elements.ctx.ellipse(x, y + size/2 + 5, size/2, size/6, 0, 0, Math.PI * 2);
    elements.ctx.fillStyle = 'rgba(0,0,0,0.5)';
    elements.ctx.fill();
    
    // Draw body
    elements.ctx.beginPath();
    elements.ctx.arc(x, y, size/2, 0, Math.PI * 2);
    elements.ctx.fillStyle = '#3298dc';
    elements.ctx.fill();
    elements.ctx.strokeStyle = '#1d6fa5';
    elements.ctx.lineWidth = 3;
    elements.ctx.stroke();
    
    // Draw eyes
    elements.ctx.beginPath();
    elements.ctx.arc(x - 10, y - 5, 5, 0, Math.PI * 2);
    elements.ctx.arc(x + 10, y - 5, 5, 0, Math.PI * 2);
    elements.ctx.fillStyle = 'white';
    elements.ctx.fill();
    
    // Draw pupils
    elements.ctx.beginPath();
    elements.ctx.arc(x - 10, y - 5, 2, 0, Math.PI * 2);
    elements.ctx.arc(x + 10, y - 5, 2, 0, Math.PI * 2);
    elements.ctx.fillStyle = 'black';
    elements.ctx.fill();
    
    // Draw mouth (smile or frown based on health)
    const healthPercent = gameState.player.health / gameState.player.maxHealth;
    elements.ctx.beginPath();
    if (healthPercent > 0.5) {
      elements.ctx.arc(x, y + 10, 10, 0, Math.PI);
    } else if (healthPercent > 0.25) {
      elements.ctx.moveTo(x - 10, y + 10);
      elements.ctx.lineTo(x + 10, y + 10);
    } else {
      elements.ctx.arc(x, y + 15, 10, Math.PI, 0);
    }
    elements.ctx.strokeStyle = 'black';
    elements.ctx.lineWidth = 2;
    elements.ctx.stroke();
    
    // Draw weapon
    elements.ctx.beginPath();
    elements.ctx.moveTo(x + size/2, y);
    elements.ctx.lineTo(x + size/2 + 30, y - 20);
    elements.ctx.lineTo(x + size/2 + 35, y - 15);
    elements.ctx.lineTo(x + size/2 + 5, y + 5);
    elements.ctx.closePath();
    elements.ctx.fillStyle = '#666';
    elements.ctx.fill();
    elements.ctx.strokeStyle = '#333';
    elements.ctx.lineWidth = 1;
    elements.ctx.stroke();
  }

  // Function to draw enemy
  function drawEnemy() {
    const x = elements.canvas.width / 2;
    const y = 150;
    const size = 80;
    const healthPercent = gameState.enemy.health / gameState.enemy.maxHealth;
    
    // Draw shadow
    elements.ctx.beginPath();
    elements.ctx.ellipse(x, y + size/2 + 5, size/2, size/6, 0, 0, Math.PI * 2);
    elements.ctx.fillStyle = 'rgba(0,0,0,0.5)';
    elements.ctx.fill();
    
    // Draw body
    elements.ctx.beginPath();
    elements.ctx.arc(x, y, size/2, 0, Math.PI * 2);
    elements.ctx.fillStyle = healthPercent > 0.5 ? '#ff3860' : 
                           healthPercent > 0.25 ? '#ff6b00' : '#990000';
    elements.ctx.fill();
    elements.ctx.strokeStyle = '#800000';
    elements.ctx.lineWidth = 3;
    elements.ctx.stroke();
    
    // Draw angry eyes
    elements.ctx.beginPath();
    elements.ctx.moveTo(x - 15, y - 10);
    elements.ctx.lineTo(x - 25, y - 15);
    elements.ctx.moveTo(x + 15, y - 10);
    elements.ctx.lineTo(x + 25, y - 15);
    elements.ctx.strokeStyle = 'black';
    elements.ctx.lineWidth = 3;
    elements.ctx.stroke();
    
    // Draw mouth (angry)
    elements.ctx.beginPath();
    elements.ctx.arc(x, y + 15, 15, 0, Math.PI);
    elements.ctx.strokeStyle = 'black';
    elements.ctx.lineWidth = 3;
    elements.ctx.stroke();
    
    // Draw horns
    elements.ctx.beginPath();
    elements.ctx.moveTo(x - 20, y - size/2);
    elements.ctx.lineTo(x - 30, y - size/2 - 20);
    elements.ctx.lineTo(x - 25, y - size/2 - 10);
    elements.ctx.moveTo(x + 20, y - size/2);
    elements.ctx.lineTo(x + 30, y - size/2 - 20);
    elements.ctx.lineTo(x + 25, y - size/2 - 10);
    elements.ctx.fillStyle = '#ffd700';
    elements.ctx.fill();
    elements.ctx.strokeStyle = '#cc9900';
    elements.ctx.lineWidth = 2;
    elements.ctx.stroke();
    
    // Draw level indicator
    elements.ctx.fillStyle = 'white';
    elements.ctx.font = 'bold 14px Arial';
    elements.ctx.textAlign = 'center';
    elements.ctx.fillText(`Lvl ${gameState.enemy.level}`, x, y - size/2 - 25);
  }

  // Function to update and draw animations
  function updateAnimations(deltaTime) {
    for (let i = gameState.animations.length - 1; i >= 0; i--) {
      const anim = gameState.animations[i];
      anim.progress = (gameState.gameTime - anim.startTime) / anim.duration;
      
      if (anim.progress >= 1) {
        gameState.animations.splice(i, 1);
        continue;
      }
      
      switch (anim.type) {
        case 'basic-attack':
          drawBasicAttackEffect(anim);
          break;
        case 'special-attack':
          drawSpecialAttackEffect(anim);
          break;
        case 'heal':
          drawHealEffect(anim);
          break;
        case 'enemy-spawn':
          drawEnemySpawnEffect(anim);
          break;
        case 'enemy-defeated':
          drawEnemyDefeatedEffect(anim);
          break;
        case 'level-up':
          drawLevelUpEffect(anim);
          break;
        case 'potion-use':
          drawPotionUseEffect(anim);
          break;
        case 'xp-boost':
          drawXpBoostEffect(anim);
          break;
      }
    }
  }

  // Function to draw basic attack effect
  function drawBasicAttackEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const size = 30 + 50 * (1 - anim.progress);
    
    elements.ctx.beginPath();
    elements.ctx.moveTo(x, y - size/2);
    elements.ctx.lineTo(x + size/2, y);
    elements.ctx.lineTo(x, y + size/2);
    elements.ctx.lineTo(x - size/2, y);
    elements.ctx.closePath();
    
    const alpha = 1 - anim.progress;
    elements.ctx.fillStyle = `rgba(255, 107, 0, ${alpha})`;
    elements.ctx.fill();
  }

  // Function to draw special attack effect
  function drawSpecialAttackEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const size = 50 + 100 * (1 - anim.progress);
    const spikes = 8;
    const innerSize = size * 0.5;
    
    elements.ctx.beginPath();
    for (let i = 0; i < spikes; i++) {
      const angle = (i / spikes) * Math.PI * 2;
      const nextAngle = ((i + 1) / spikes) * Math.PI * 2;
      
      // Outer point
      const outerX = x + Math.cos(angle) * size;
      const outerY = y + Math.sin(angle) * size;
      
      // Inner point
      const innerX = x + Math.cos(angle + Math.PI/spikes) * innerSize;
      const innerY = y + Math.sin(angle + Math.PI/spikes) * innerSize;
      
      // Next outer point
      const nextOuterX = x + Math.cos(nextAngle) * size;
      const nextOuterY = y + Math.sin(nextAngle) * size;
      
      if (i === 0) {
        elements.ctx.moveTo(outerX, outerY);
      } else {
        elements.ctx.lineTo(outerX, outerY);
      }
      
      elements.ctx.lineTo(innerX, innerY);
    }
    elements.ctx.closePath();
    
    const alpha = 1 - anim.progress;
    elements.ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
    elements.ctx.fill();
  }

  // Function to draw heal effect
  function drawHealEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const size = 30 + 70 * (1 - anim.progress);
    const points = 5;
    const innerSize = size * 0.5;
    
    elements.ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const angle = (i / points) * Math.PI;
      const radius = i % 2 === 0 ? size : innerSize;
      
      const pointX = x + Math.cos(angle) * radius;
      const pointY = y + Math.sin(angle) * radius;
      
      if (i === 0) {
        elements.ctx.moveTo(pointX, pointY);
      } else {
        elements.ctx.lineTo(pointX, pointY);
      }
    }
    elements.ctx.closePath();
    
    const alpha = 1 - anim.progress;
    elements.ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
    elements.ctx.fill();
  }

  // Function to draw enemy spawn effect
  function drawEnemySpawnEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const rings = 3;
    
    for (let i = 0; i < rings; i++) {
      const ringProgress = Math.max(0, anim.progress - (i * 0.2));
      if (ringProgress >= 1) continue;
      
      const size = 50 + 150 * (1 - ringProgress);
      const alpha = 0.7 * (1 - ringProgress);
      
      elements.ctx.beginPath();
      elements.ctx.arc(x, y, size, 0, Math.PI * 2);
      elements.ctx.strokeStyle = `rgba(255, 56, 96, ${alpha})`;
      elements.ctx.lineWidth = 3;
      elements.ctx.stroke();
    }
  }

  // Function to draw enemy defeated effect
  function drawEnemyDefeatedEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const particleCount = 5;
    const size = 100 * (1 - anim.progress);
    
    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2 + anim.progress * Math.PI;
      const distance = size * 0.5;
      
      const particleX = x + Math.cos(angle) * distance;
      const particleY = y + Math.sin(angle) * distance;
      const particleSize = 5 + 10 * (1 - anim.progress);
      
      elements.ctx.beginPath();
      elements.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
      elements.ctx.fillStyle = `rgba(255, 215, 0, ${1 - anim.progress})`;
      elements.ctx.fill();
    }
  }

  // Function to draw level up effect
  function drawLevelUpEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const rings = 5;
    
    for (let i = 0; i < rings; i++) {
      const ringProgress = Math.max(0, anim.progress - (i * 0.15));
      if (ringProgress >= 1) continue;
      
      const size = 30 + 100 * (1 - ringProgress);
      const alpha = 0.6 * (1 - ringProgress);
      
      elements.ctx.beginPath();
      elements.ctx.arc(x, y, size, 0, Math.PI * 2);
      elements.ctx.strokeStyle = `rgba(50, 152, 220, ${alpha})`;
      elements.ctx.lineWidth = 2 + 3 * (1 - ringProgress);
      elements.ctx.stroke();
    }
  }

  // Function to draw potion use effect
  function drawPotionUseEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const drops = 8;
    
    for (let i = 0; i < drops; i++) {
      const dropProgress = Math.max(0, anim.progress - (i * 0.1));
      if (dropProgress >= 1) continue;
      
      const dropY = y - 50 * dropProgress;
      const dropSize = 5 + 5 * (1 - dropProgress);
      
      elements.ctx.beginPath();
      elements.ctx.arc(x, dropY, dropSize, 0, Math.PI * 2);
      elements.ctx.fillStyle = `rgba(0, 255, 136, ${1 - dropProgress})`;
      elements.ctx.fill();
    }
  }

  // Function to draw XP boost effect
  function drawXpBoostEffect(anim) {
    const x = anim.position.x;
    const y = anim.position.y;
    const stars = 8;
    
    for (let i = 0; i < stars; i++) {
      const starProgress = Math.max(0, anim.progress - (i * 0.1));
      if (starProgress >= 1) continue;
      
      const angle = (i / stars) * Math.PI * 2;
      const distance = 30 + 70 * (1 - starProgress);
      
      const starX = x + Math.cos(angle) * distance;
      const starY = y + Math.sin(angle) * distance;
      const starSize = 3 + 7 * (1 - starProgress);
      
      drawStar(starX, starY, starSize, `rgba(50, 152, 220, ${1 - starProgress})`);
    }
  }

  // Function to draw a star
  function drawStar(x, y, size, color) {
    const spikes = 5;
    const outerRadius = size;
    const innerRadius = size * 0.4;
    
    elements.ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
      const angle = (i / spikes) * Math.PI;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      
      const pointX = x + Math.cos(angle) * radius;
      const pointY = y + Math.sin(angle) * radius;
      
      if (i === 0) {
        elements.ctx.moveTo(pointX, pointY);
      } else {
        elements.ctx.lineTo(pointX, pointY);
      }
    }
    elements.ctx.closePath();
    elements.ctx.fillStyle = color;
    elements.ctx.fill();
  }

  // Function to update and draw particles
  function updateParticles(deltaTime) {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
      const p = gameState.particles[i];
      const lifetimeProgress = (gameState.gameTime - p.startTime) / p.lifetime;
      
      if (lifetimeProgress >= 1) {
        gameState.particles.splice(i, 1);
        continue;
      }
      
      // Update position
      p.x += p.vx;
      p.y += p.vy;
      
      // Apply gravity
      p.vy += 0.05;
      
      // Fade out
      p.alpha = 1 - lifetimeProgress;
      
      // Draw particle
      elements.ctx.beginPath();
      elements.ctx.arc(p.x, p.y, p.size * (1 - lifetimeProgress * 0.5), 0, Math.PI * 2);
      elements.ctx.fillStyle = `rgba(${hexToRgb(p.color)}, ${p.alpha})`;
      elements.ctx.fill();
    }
  }

  // Helper function to convert hex to rgb
  function hexToRgb(hex) {
    const r = parseInt(hex.substring(1, 3), 16);
    const g = parseInt(hex.substring(3, 5), 16);
    const b = parseInt(hex.substring(5, 7), 16);
    return `${r}, ${g}, ${b}`;
  }

  // Event listeners
  elements.basicAttackBtn.addEventListener('click', basicAttack);
  elements.specialAttackBtn.addEventListener('click', specialAttack);
  elements.healBtn.addEventListener('click', heal);
  elements.walletBtn.addEventListener('click', connectWallet);
  elements.inventoryBtn.addEventListener('click', () => {
    elements.inventory.style.display = elements.inventory.style.display === 'block' ? 'none' : 'block';
  });
  elements.useHealthPotionBtn.addEventListener('click', useHealthPotion);
  elements.restartBtn.addEventListener('click', initGame);

  // Initialize the game
  initGame();
</script>
</body>
</html>